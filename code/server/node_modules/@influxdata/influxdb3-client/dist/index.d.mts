/** IllegalArgumentError is thrown when illegal argument is supplied. */
declare class IllegalArgumentError extends Error {
    constructor(message: string);
}
/**
 * A general HTTP error.
 */
declare class HttpError extends Error {
    readonly statusCode: number;
    readonly statusMessage: string | undefined;
    readonly body?: string | undefined;
    readonly contentType?: string | null | undefined;
    /** application error code, when available */
    code: string | undefined;
    /** json error response */
    json: any;
    constructor(statusCode: number, statusMessage: string | undefined, body?: string | undefined, contentType?: string | null | undefined, message?: string);
}
/** RequestTimedOutError indicates request timeout in the communication with the server */
declare class RequestTimedOutError extends Error {
    constructor();
}
/** AbortError indicates that the communication with the server was aborted */
declare class AbortError extends Error {
    constructor();
}

/**
 * ChunkCombiner is a simplified platform-neutral manipulation of Uint8arrays
 * that allows to process text data on the fly. The implementation can be optimized
 * for the target platform (node vs browser).
 */
interface ChunkCombiner {
    /**
     * Concatenates first and second chunk.
     * @param first - first chunk
     * @param second - second chunk
     * @returns first + second
     */
    concat(first: Uint8Array, second: Uint8Array): Uint8Array;
    /**
     * Converts chunk into a string.
     * @param chunk - chunk
     * @param start - start index
     * @param end - end index
     * @returns string representation of chunk slice
     */
    toUtf8String(chunk: Uint8Array, start: number, end: number): string;
    /**
     * Creates a new chunk from the supplied chunk.
     * @param chunk - chunk to copy
     * @param start - start index
     * @param end - end index
     * @returns a copy of a chunk slice
     */
    copy(chunk: Uint8Array, start: number, end: number): Uint8Array;
}
/**
 * Creates a chunk combiner instance that uses UTF-8
 * TextDecoder to decode Uint8Arrays into strings.
 */
declare function createTextDecoderCombiner(): ChunkCombiner;

/**
 * Allows to cancel a running execution.
 */
interface Cancellable {
    /**
     * Cancels execution.
     */
    cancel(): void;
    isCancelled(): boolean;
}

/**
 * Type of HTTP headers.
 */
type HttpHeaders = {
    [header: string]: string | string[] | undefined;
};

/**
 * Informs about a start of response processing.
 * @param headers - response HTTP headers
 * @param statusCode - response status code
 */
type ResponseStartedFn = (headers: HttpHeaders, statusCode?: number) => void;
/**
 * Observes communication with the server.
 */
interface CommunicationObserver<T> {
    /**
     * Data chunk received, can be called multiple times.
     * @param data - data
     * @returns when `false` value is returned and {@link CommunicationObserver.useResume} is defined,
     * future calls to `next` are paused until resume is called.
     */
    next(data: T): void | boolean;
    /**
     * Communication ended with an error.
     */
    error(error: Error): void;
    /**
     * Communication was successful.
     */
    complete(): void;
    /**
     * Informs about a start of response processing.
     */
    responseStarted?: ResponseStartedFn;
    /**
     * Setups cancelllable for this communication.
     */
    useCancellable?: (cancellable: Cancellable) => void;
    /**
     * Setups a callback that resumes reading of next data, it is called whenever
     * {@link CommunicationObserver.next} returns `false`.
     *
     * @param resume - a function that will resume reading of next data when called
     */
    useResume?: (resume: () => void) => void;
}

/**
 * Options for sending a request message.
 */
interface SendOptions {
    /** HTTP method (POST, PUT, GET, PATCH ...) */
    method: string;
    /** Request HTTP headers. */
    headers?: {
        [key: string]: string;
    };
    /** When specified, message body larger than the treshold is gzipped  */
    gzipThreshold?: number;
    /** Abort signal */
    signal?: AbortSignal;
}
/**
 * Simpified platform-neutral transport layer for communication with InfluxDB.
 */
interface Transport {
    /**
     * Send data to the server and receive communication events via callbacks.
     *
     * @param path - HTTP request path
     * @param requestBody - HTTP request body
     * @param options  - send options
     * @param callbacks - communication callbacks to received data in Uint8Array
     */
    send(path: string, requestBody: string, options: SendOptions, callbacks?: Partial<CommunicationObserver<Uint8Array>>): void;
    /**
     * Sends data to the server and receives decoded result. The type of the result depends on
     * response's content-type (deserialized json, text).
  
     * @param path - HTTP request path
     * @param requestBody - request body
     * @param options - send options
     * @returns response data
     */
    request(path: string, requestBody: any, options: SendOptions, responseStarted?: ResponseStartedFn): Promise<any>;
    /**
     * Sends requestBody and returns response chunks in an async iterable
     * that can be easily consumed in an `for-await` loop.
     *
     * @param path - HTTP request path
     * @param requestBody - request body
     * @param options - send options
     * @returns async iterable
     */
    iterate(path: string, requestBody: any, options: SendOptions): AsyncIterableIterator<Uint8Array>;
}

/**
 * Option for the communication with InfluxDB server.
 */
interface ConnectionOptions {
    /** base host URL */
    host: string;
    /** authentication token */
    token?: string;
    /**
     * socket timeout, 10000 milliseconds by default in node.js
     * @defaultValue 10000
     */
    timeout?: number;
    /**
     * default database for write query if not present as argument.
     */
    database?: string;
    /**
     * TransportOptions supply extra options for the transport layer, they differ between node.js and browser/deno.
     * Node.js transport accepts options specified in {@link https://nodejs.org/api/http.html#http_http_request_options_callback | http.request } or
     * {@link https://nodejs.org/api/https.html#https_https_request_options_callback | https.request }. For example, an `agent` property can be set to
     * {@link https://www.npmjs.com/package/proxy-http-agent | setup HTTP/HTTPS proxy }, {@link  https://nodejs.org/api/tls.html#tls_tls_connect_options_callback | rejectUnauthorized }
     * property can disable TLS server certificate verification. Additionally,
     * {@link https://github.com/follow-redirects/follow-redirects | follow-redirects } property can be also specified
     * in order to follow redirects in node.js.
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/fetch | fetch } is used under the hood in browser/deno.
     * For example,
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/fetch | redirect } property can be set to 'error' to abort request if a redirect occurs.
     */
    transportOptions?: {
        [key: string]: any;
    };
    /**
     * Default HTTP headers to send with every request.
     */
    headers?: Record<string, string>;
    /**
     * Full HTTP web proxy URL including schema, for example http://your-proxy:8080.
     */
    proxyUrl?: string;
}
/** default connection options */
declare const DEFAULT_ConnectionOptions: Partial<ConnectionOptions>;
/**
 * Options used by {@link InfluxDBClient.write} .
 */
interface WriteOptions {
    /** Precision to use in writes for timestamp. default ns */
    precision: WritePrecision;
    /** HTTP headers that will be sent with every write request */
    headers?: {
        [key: string]: string;
    };
    /** When specified, write bodies larger than the threshold are gzipped  */
    gzipThreshold?: number;
    /** InfluxDB Enterprise write consistency as explained in https://docs.influxdata.com/enterprise_influxdb/v1.9/concepts/clustering/#write-consistency */
    consistency?: 'any' | 'one' | 'quorum' | 'all';
}
/** default writeOptions */
declare const DEFAULT_WriteOptions: WriteOptions;
type QueryType = 'sql' | 'influxql';
/**
 * Options used by {@link InfluxDBClient} .
 */
interface ClientOptions extends ConnectionOptions {
    /** supplies and overrides default writing options */
    writeOptions?: Partial<WriteOptions>;
    /** specifies custom transport */
    transport?: Transport;
}
/**
 * Timestamp precision used in write operations.
 * See {@link https://docs.influxdata.com/influxdb/latest/api/#operation/PostWrite }
 */
type WritePrecision = 'ns' | 'us' | 'ms' | 's';

/**
 * Logging interface.
 */
interface Logger {
    error(message: string, err?: any): void;
    warn(message: string, err?: any): void;
}
/**
 * Logger that logs to console.out
 */
declare const consoleLogger: Logger;
declare const Log: Logger;
/**
 * Sets custom logger.
 * @param logger - logger to use
 * @returns previous logger
 */
declare function setLogger(logger: Logger): Logger;

/**
 * Provides functions escape specific parts in InfluxDB line protocol.
 */
declare const escape: {
    /**
     * Measurement escapes measurement names.
     */
    measurement: (value: string) => string;
    /**
     * Quoted escapes quoted values, such as database names.
     */
    quoted: (value: string) => string;
    /**
     * TagEscaper escapes tag keys, tag values, and field keys.
     */
    tag: (value: string) => string;
};

declare function useProcessHrtime(use: boolean): boolean;
/**
 * Exposes functions that creates strings that represent a timestamp that
 * can be used in the line protocol. Micro and nano timestamps are emulated
 * depending on the js platform in use.
 */
declare const currentTime: {
    s: () => string;
    ms: () => string;
    us: () => string;
    ns: () => string;
    seconds: () => string;
    millis: () => string;
    micros: () => string;
    nanos: () => string;
};
/**
 * dateToProtocolTimestamp provides converters for JavaScript Date to InfluxDB Write Protocol Timestamp. Keys are supported precisions.
 */
declare const dateToProtocolTimestamp: {
    s: (d: Date) => string;
    ms: (d: Date) => string;
    us: (d: Date) => string;
    ns: (d: Date) => string;
};
/**
 * convertTimeToNanos converts Point's timestamp to a string.
 * @param value - supported timestamp value
 * @returns line protocol value
 */
declare function convertTimeToNanos(value: string | number | Date | undefined): string | undefined;
declare const convertTime: (value: string | number | Date | undefined, precision?: WritePrecision) => string | undefined;

interface TimeConverter {
    (value: string | number | Date | undefined): string | undefined;
}

type PointFieldType = 'float' | 'integer' | 'uinteger' | 'string' | 'boolean';
declare class GetFieldTypeMissmatchError extends Error {
    constructor(fieldName: string, expectedType: PointFieldType, actualType: PointFieldType);
}
/**
 * Point defines values of a single measurement.
 */
declare class PointValues {
    private _name;
    private _time;
    private _tags;
    private _fields;
    /**
     * Create an empty PointValues.
     */
    constructor();
    /**
     * Get measurement name. Can be undefined if not set.
     *
     * @returns measurement name or undefined
     */
    getMeasurement(): string | undefined;
    /**
     * Sets point's measurement.
     *
     * @param name - measurement name
     * @returns this
     */
    setMeasurement(name: string): PointValues;
    /**
     * Get timestamp. Can be undefined if not set.
     *
     * @returns timestamp or undefined
     */
    getTimestamp(): Date | number | string | undefined;
    /**
     * Sets point timestamp. Timestamp can be specified as a Date (preferred), number, string
     * or an undefined value. An undefined value instructs to assign a local timestamp using
     * the client's clock. An empty string can be used to let the server assign
     * the timestamp. A number value represents time as a count of time units since epoch, the
     * exact time unit then depends on the {@link InfluxDBClient.write | precision} of the API
     * that writes the point.
     *
     * Beware that the current time in nanoseconds can't precisely fit into a JS number,
     * which can hold at most 2^53 integer number. Nanosecond precision numbers are thus supplied as
     * a (base-10) string. An application can also use ES2020 BigInt to represent nanoseconds,
     * BigInt's `toString()` returns the required high-precision string.
     *
     * Note that InfluxDB requires the timestamp to fit into int64 data type.
     *
     * @param value - point time
     * @returns this
     */
    setTimestamp(value: Date | number | string | undefined): PointValues;
    /**
     * Gets value of tag with given name. Returns undefined if tag not found.
     *
     * @param name - tag name
     * @returns tag value or undefined
     */
    getTag(name: string): string | undefined;
    /**
     * Sets a tag. The caller has to ensure that both name and value are not empty
     * and do not end with backslash.
     *
     * @param name - tag name
     * @param value - tag value
     * @returns this
     */
    setTag(name: string, value: string): PointValues;
    /**
     * Removes a tag with the specified name if it exists; otherwise, it does nothing.
     *
     * @param name - The name of the tag to be removed.
     * @returns this
     */
    removeTag(name: string): PointValues;
    /**
     * Gets an array of tag names.
     *
     * @returns An array of tag names.
     */
    getTagNames(): string[];
    /**
     * Gets the float field value associated with the specified name.
     * Throws if actual type of field with given name is not float.
     * If the field is not present, returns undefined.
     *
     * @param name - field name
     * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match float type.
     * @returns The float field value or undefined.
     */
    getFloatField(name: string): number | undefined;
    /**
     * Sets a number field.
     *
     * @param name - field name
     * @param value - field value
     * @returns this
     * @throws NaN/Infinity/-Infinity is supplied
     */
    setFloatField(name: string, value: number | any): PointValues;
    /**
     * Gets the integer field value associated with the specified name.
     * Throws if actual type of field with given name is not integer.
     * If the field is not present, returns undefined.
     *
     * @param name - field name
     * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match integer type.
     * @returns The integer field value or undefined.
     */
    getIntegerField(name: string): number | undefined;
    /**
     * Sets an integer field.
     *
     * @param name - field name
     * @param value - field value
     * @returns this
     * @throws NaN or out of int64 range value is supplied
     */
    setIntegerField(name: string, value: number | any): PointValues;
    /**
     * Gets the uint field value associated with the specified name.
     * Throws if actual type of field with given name is not uint.
     * If the field is not present, returns undefined.
     *
     * @param name - field name
     * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match uint type.
     * @returns The uint field value or undefined.
     */
    getUintegerField(name: string): number | undefined;
    /**
     * Sets an unsigned integer field.
     *
     * @param name - field name
     * @param value - field value
     * @returns this
     * @throws NaN out of range value is supplied
     */
    setUintegerField(name: string, value: number | any): PointValues;
    /**
     * Gets the string field value associated with the specified name.
     * Throws if actual type of field with given name is not string.
     * If the field is not present, returns undefined.
     *
     * @param name - field name
     * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match string type.
     * @returns The string field value or undefined.
     */
    getStringField(name: string): string | undefined;
    /**
     * Sets a string field.
     *
     * @param name - field name
     * @param value - field value
     * @returns this
     */
    setStringField(name: string, value: string | any): PointValues;
    /**
     * Gets the boolean field value associated with the specified name.
     * Throws if actual type of field with given name is not boolean.
     * If the field is not present, returns undefined.
     *
     * @param name - field name
     * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match boolean type.
     * @returns The boolean field value or undefined.
     */
    getBooleanField(name: string): boolean | undefined;
    /**
     * Sets a boolean field.
     *
     * @param name - field name
     * @param value - field value
     * @returns this
     */
    setBooleanField(name: string, value: boolean | any): PointValues;
    /**
     * Get field of numeric type.
     * Throws if actual type of field with given name is not given numeric type.
     * If the field is not present, returns undefined.
     *
     * @param name - field name
     * @param type - field numeric type
     * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match provided numeric type.
     * @returns this
     */
    getField(name: string, type: 'float' | 'integer' | 'uinteger'): number | undefined;
    /**
     * Get field of string type.
     * Throws if actual type of field with given name is not string.
     * If the field is not present, returns undefined.
     *
     * @param name - field name
     * @param type - field string type
     * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match provided 'string' type.
     * @returns this
     */
    getField(name: string, type: 'string'): string | undefined;
    /**
     * Get field of boolean type.
     * Throws if actual type of field with given name is not boolean.
     * If the field is not present, returns undefined.
     *
     * @param name - field name
     * @param type - field boolean type
     * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match provided 'boolean' type.
     * @returns this
     */
    getField(name: string, type: 'boolean'): boolean | undefined;
    /**
     * Get field without type check.
     * If the field is not present, returns undefined.
     *
     * @param name - field name
     * @returns this
     */
    getField(name: string): number | string | boolean | undefined;
    /**
     * Gets the type of field with given name, if it exists.
     * If the field is not present, returns undefined.
     *
     * @param name - field name
     * @returns The field type or undefined.
     */
    getFieldType(name: string): PointFieldType | undefined;
    /**
     * Sets field based on provided type.
     *
     * @param name - field name
     * @param value - field value
     * @param type - field type
     * @returns this
     */
    setField(name: string, value: any, type?: PointFieldType): PointValues;
    /**
     * Add fields according to their type. All numeric type is considered float
     *
     * @param fields - name-value map
     * @returns this
     */
    setFields(fields: {
        [key: string]: number | boolean | string;
    }): PointValues;
    /**
     * Removes a field with the specified name if it exists; otherwise, it does nothing.
     *
     * @param name - The name of the field to be removed.
     * @returns this
     */
    removeField(name: string): PointValues;
    /**
     * Gets an array of field names associated with this object.
     *
     * @returns An array of field names.
     */
    getFieldNames(): string[];
    /**
     * Checks if this object has any fields.
     *
     * @returns true if fields are present, false otherwise.
     */
    hasFields(): boolean;
    /**
     * Creates a copy of this object.
     *
     * @returns A new instance with same values.
     */
    copy(): PointValues;
    /**
     * Creates new Point with this as values.
     *
     * @returns Point from this values.
     */
    asPoint(measurement?: string): Point;
}

/**
 * Point defines values of a single measurement.
 */
declare class Point {
    private readonly _values;
    /**
     * Create a new Point with specified a measurement name.
     *
     * @param measurementName - the measurement name
     */
    private constructor();
    /**
     * Create a new Point with given values.
     * After creating Point, it's values shouldn't be modified directly by PointValues object.
     *
     * @param values - point values
     */
    private constructor();
    /**
     * Creates new Point with given measurement.
     *
     * @param name - measurement name
     * @returns new Point
     */
    static measurement(name: string): Point;
    /**
     * Creates new point from PointValues object.
     * Can throw error if measurement missing.
     *
     * @param values - point values object with measurement
     * @throws missing measurement
     * @returns new point from values
     */
    static fromValues(values: PointValues): Point;
    /**
     * Get measurement name.
     *
     * @returns measurement name
     */
    getMeasurement(): string;
    /**
     * Sets point's measurement.
     *
     * @param name - measurement name
     * @returns this
     */
    setMeasurement(name: string): Point;
    /**
     * Get timestamp. Can be undefined if not set.
     *
     * @returns timestamp or undefined
     */
    getTimestamp(): Date | number | string | undefined;
    /**
     * Sets point timestamp. Timestamp can be specified as a Date (preferred), number, string
     * or an undefined value. An undefined value instructs to assign a local timestamp using
     * the client's clock. An empty string can be used to let the server assign
     * the timestamp. A number value represents time as a count of time units since epoch, the
     * exact time unit then depends on the {@link InfluxDBClient.write | precision} of the API
     * that writes the point.
     *
     * Beware that the current time in nanoseconds can't precisely fit into a JS number,
     * which can hold at most 2^53 integer number. Nanosecond precision numbers are thus supplied as
     * a (base-10) string. An application can also use ES2020 BigInt to represent nanoseconds,
     * BigInt's `toString()` returns the required high-precision string.
     *
     * Note that InfluxDB requires the timestamp to fit into int64 data type.
     *
     * @param value - point time
     * @returns this
     */
    setTimestamp(value: Date | number | string | undefined): Point;
    /**
     * Gets value of tag with given name. Returns undefined if tag not found.
     *
     * @param name - tag name
     * @returns tag value or undefined
     */
    getTag(name: string): string | undefined;
    /**
     * Sets a tag. The caller has to ensure that both name and value are not empty
     * and do not end with backslash.
     *
     * @param name - tag name
     * @param value - tag value
     * @returns this
     */
    setTag(name: string, value: string): Point;
    /**
     * Removes a tag with the specified name if it exists; otherwise, it does nothing.
     *
     * @param name - The name of the tag to be removed.
     * @returns this
     */
    removeTag(name: string): Point;
    /**
     * Gets an array of tag names.
     *
     * @returns An array of tag names.
     */
    getTagNames(): string[];
    /**
     * Gets the float field value associated with the specified name.
     * Throws if actual type of field with given name is not float.
     * If the field is not present, returns undefined.
     *
     * @param name - field name
     * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match float type.
     * @returns The float field value or undefined.
     */
    getFloatField(name: string): number | undefined;
    /**
     * Sets a number field.
     *
     * @param name - field name
     * @param value - field value
     * @returns this
     * @throws NaN/Infinity/-Infinity is supplied
     */
    setFloatField(name: string, value: number | any): Point;
    /**
     * Gets the integer field value associated with the specified name.
     * Throws if actual type of field with given name is not integer.
     * If the field is not present, returns undefined.
     *
     * @param name - field name
     * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match integer type.
     * @returns The integer field value or undefined.
     */
    getIntegerField(name: string): number | undefined;
    /**
     * Sets an integer field.
     *
     * @param name - field name
     * @param value - field value
     * @returns this
     * @throws NaN or out of int64 range value is supplied
     */
    setIntegerField(name: string, value: number | any): Point;
    /**
     * Gets the uint field value associated with the specified name.
     * Throws if actual type of field with given name is not uint.
     * If the field is not present, returns undefined.
     *
     * @param name - field name
     * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match uint type.
     * @returns The uint field value or undefined.
     */
    getUintegerField(name: string): number | undefined;
    /**
     * Sets an unsigned integer field.
     *
     * @param name - field name
     * @param value - field value
     * @returns this
     * @throws NaN out of range value is supplied
     */
    setUintegerField(name: string, value: number | any): Point;
    /**
     * Gets the string field value associated with the specified name.
     * Throws if actual type of field with given name is not string.
     * If the field is not present, returns undefined.
     *
     * @param name - field name
     * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match string type.
     * @returns The string field value or undefined.
     */
    getStringField(name: string): string | undefined;
    /**
     * Sets a string field.
     *
     * @param name - field name
     * @param value - field value
     * @returns this
     */
    setStringField(name: string, value: string | any): Point;
    /**
     * Gets the boolean field value associated with the specified name.
     * Throws if actual type of field with given name is not boolean.
     * If the field is not present, returns undefined.
     *
     * @param name - field name
     * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match boolean type.
     * @returns The boolean field value or undefined.
     */
    getBooleanField(name: string): boolean | undefined;
    /**
     * Sets a boolean field.
     *
     * @param name - field name
     * @param value - field value
     * @returns this
     */
    setBooleanField(name: string, value: boolean | any): Point;
    /**
     * Get field of numeric type.
     *
     * @param name - field name
     * @param type - field numeric type
     * @throws Field type doesn't match actual type
     * @returns this
     */
    getField(name: string, type: 'float' | 'integer' | 'uinteger'): number | undefined;
    /**
     * Get field of string type.
     *
     * @param name - field name
     * @param type - field string type
     * @throws Field type doesn't match actual type
     * @returns this
     */
    getField(name: string, type: 'string'): string | undefined;
    /**
     * Get field of boolean type.
     *
     * @param name - field name
     * @param type - field boolean type
     * @throws Field type doesn't match actual type
     * @returns this
     */
    getField(name: string, type: 'boolean'): boolean | undefined;
    /**
     * Get field without type check.
     *
     * @param name - field name
     * @returns this
     */
    getField(name: string): number | string | boolean | undefined;
    /**
     * Gets the type of field with given name, if it exists.
     * If the field is not present, returns undefined.
     *
     * @param name - field name
     * @returns The field type or undefined.
     */
    getFieldType(name: string): PointFieldType | undefined;
    /**
     * Sets field based on provided type.
     *
     * @param name - field name
     * @param value - field value
     * @param type - field type
     * @returns this
     */
    setField(name: string, value: any, type?: PointFieldType): Point;
    /**
     * Add fields according to their type. All numeric type is considered float
     *
     * @param fields - name-value map
     * @returns this
     */
    setFields(fields: {
        [key: string]: number | boolean | string;
    }): Point;
    /**
     * Removes a field with the specified name if it exists; otherwise, it does nothing.
     *
     * @param name - The name of the field to be removed.
     * @returns this
     */
    removeField(name: string): Point;
    /**
     * Gets an array of field names associated with this object.
     *
     * @returns An array of field names.
     */
    getFieldNames(): string[];
    /**
     * Checks if this object has any fields.
     *
     * @returns true if fields are present, false otherwise.
     */
    hasFields(): boolean;
    /**
     * Creates a copy of this object.
     *
     * @returns A new instance with same values.
     */
    copy(): Point;
    /**
     * Creates an InfluxDB protocol line out of this instance.
     * @param convertTimePrecision - settings control serialization of a point timestamp and can also add default tags,
     * nanosecond timestamp precision is used when no `settings` or no `settings.convertTime` is supplied.
     * @returns an InfluxDB protocol line out of this instance
     */
    toLineProtocol(convertTimePrecision?: TimeConverter | WritePrecision): string | undefined;
    toString(): string;
}

/**
 * The `WritableData` type represents different types of data that can be written.
 * The data can either be a uniform ArrayLike collection or a single value of the following types:
 *
 * - `Point`: Represents a {@link Point} object.
 *
 * - `string`: Represents lines of the [Line Protocol](https://bit.ly/2QL99fu).
 */
type WritableData = ArrayLike<string> | ArrayLike<Point> | string | Point;
declare const writableDataToLineProtocol: (data: WritableData) => string[];

declare const collectAll: <T>(generator: AsyncGenerator<T, any, any>) => Promise<T[]>;

/**
 * `InfluxDBClient` for interacting with an InfluxDB server, simplifying common operations such as writing, querying.
 */
declare class InfluxDBClient {
    private readonly _options;
    private readonly _writeApi;
    private readonly _queryApi;
    /**
     * Creates a new instance of the `InfluxDBClient` for interacting with an InfluxDB server, simplifying common operations such as writing, querying.
     * @param options - client options
     */
    constructor(options: ClientOptions);
    private _mergeWriteOptions;
    /**
     * Write data into specified database.
     * @param data - data to write
     * @param database - database to write into
     * @param org - organization to write into
     * @param writeOptions - write options
     */
    write(data: WritableData, database?: string, org?: string, writeOptions?: Partial<WriteOptions>): Promise<void>;
    /**
     * Execute a query and return the results as an async generator.
     *
     * @param query - The query string.
     * @param database - The name of the database to query.
     * @param queryType - The type of query (default: 'sql').
     * @returns An async generator that yields maps of string keys to any values.
     */
    query(query: string, database?: string, queryType?: QueryType): AsyncGenerator<Record<string, any>, void, void>;
    /**
     * Execute a query and return the results as an async generator.
     *
     * @param query - The query string.
     * @param database - The name of the database to query.
     * @param queryType - The type of query (default: 'sql').
     * @returns An async generator that yields PointValues object.
     */
    queryPoints(query: string, database?: string, queryType?: QueryType): AsyncGenerator<PointValues, void, void>;
    /**
     * Closes the client and all its resources (connections, ...)
     */
    close(): Promise<void>;
}

export { AbortError, Cancellable, ChunkCombiner, ClientOptions, CommunicationObserver, ConnectionOptions, DEFAULT_ConnectionOptions, DEFAULT_WriteOptions, GetFieldTypeMissmatchError, HttpHeaders as Headers, HttpError, HttpHeaders, IllegalArgumentError, InfluxDBClient, Log, Logger, Point, PointFieldType, PointValues, QueryType, RequestTimedOutError, ResponseStartedFn, SendOptions, TimeConverter, Transport, WritableData, WriteOptions, WritePrecision, collectAll, consoleLogger, convertTime, convertTimeToNanos, createTextDecoderCombiner, currentTime, dateToProtocolTimestamp, escape, setLogger, useProcessHrtime, writableDataToLineProtocol };
