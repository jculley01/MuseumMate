{"version":3,"sources":["../src/index.ts","../src/errors.ts","../src/results/chunkCombiner.ts","../src/options.ts","../src/util/logger.ts","../src/util/escape.ts","../src/util/time.ts","../src/util/common.ts","../src/util/generics.ts","../src/PointValues.ts","../src/Point.ts","../src/impl/node/NodeHttpTransport.ts","../src/impl/completeCommunicationObserver.ts","../src/impl/version.ts","../src/impl/node/rpc.ts","../src/util/fixUrl.ts","../src/impl/node/index.ts","../src/impl/WriteApiImpl.ts","../src/impl/QueryApiImpl.ts","../src/generated/flight/Flight.ts","../../../node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/base64.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/assert.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/oneof.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js","../../../node_modules/@protobuf-ts/runtime/build/es2015/message-type.js","../src/generated/flight/google/protobuf/timestamp.ts","../src/generated/flight/Flight.client.ts","../src/InfluxDBClient.ts"],"sourcesContent":["export * from './errors'\nexport * from './results'\nexport * from './options'\nexport * from './transport'\nexport * from './util/logger'\nexport * from './util/escape'\nexport * from './util/time'\nexport * from './util/generics'\nexport {collectAll} from './util/common'\nexport * from './Point'\nexport * from './PointValues'\nexport {default as InfluxDBClient} from './InfluxDBClient'\nexport {TimeConverter} from './WriteApi'\n","/** IllegalArgumentError is thrown when illegal argument is supplied. */\nexport class IllegalArgumentError extends Error {\n  /* istanbul ignore next */\n  constructor(message: string) {\n    super(message)\n    this.name = 'IllegalArgumentError'\n    Object.setPrototypeOf(this, IllegalArgumentError.prototype)\n  }\n}\n\n/**\n * A general HTTP error.\n */\nexport class HttpError extends Error {\n  /** application error code, when available */\n  public code: string | undefined\n  /** json error response */\n  public json: any\n\n  /* istanbul ignore next because of super() not being covered*/\n  constructor(\n    readonly statusCode: number,\n    readonly statusMessage: string | undefined,\n    readonly body?: string,\n    readonly contentType?: string | undefined | null,\n    message?: string\n  ) {\n    super()\n    Object.setPrototypeOf(this, HttpError.prototype)\n    if (message) {\n      this.message = message\n    } else if (body) {\n      if (contentType?.startsWith('application/json')) {\n        try {\n          this.json = JSON.parse(body)\n          this.message = this.json.message\n          this.code = this.json.code\n        } catch (e) {\n          // silently ignore, body string is still available\n        }\n      }\n      if (!this.message) {\n        this.message = `${statusCode} ${statusMessage} : ${body}`\n      }\n    } else {\n      this.message = `${statusCode} ${statusMessage}`\n    }\n    this.name = 'HttpError'\n  }\n}\n\n/** RequestTimedOutError indicates request timeout in the communication with the server */\nexport class RequestTimedOutError extends Error {\n  /* istanbul ignore next because of super() not being covered */\n  constructor() {\n    super()\n    Object.setPrototypeOf(this, RequestTimedOutError.prototype)\n    this.name = 'RequestTimedOutError'\n    this.message = 'Request timed out'\n  }\n}\n\n/** AbortError indicates that the communication with the server was aborted */\nexport class AbortError extends Error {\n  /* istanbul ignore next because of super() not being covered */\n  constructor() {\n    super()\n    this.name = 'AbortError'\n    Object.setPrototypeOf(this, AbortError.prototype)\n    this.message = 'Response aborted'\n  }\n}\n","/**\n * ChunkCombiner is a simplified platform-neutral manipulation of Uint8arrays\n * that allows to process text data on the fly. The implementation can be optimized\n * for the target platform (node vs browser).\n */\nexport interface ChunkCombiner {\n  /**\n   * Concatenates first and second chunk.\n   * @param first - first chunk\n   * @param second - second chunk\n   * @returns first + second\n   */\n  concat(first: Uint8Array, second: Uint8Array): Uint8Array\n\n  /**\n   * Converts chunk into a string.\n   * @param chunk - chunk\n   * @param start - start index\n   * @param end - end index\n   * @returns string representation of chunk slice\n   */\n  toUtf8String(chunk: Uint8Array, start: number, end: number): string\n\n  /**\n   * Creates a new chunk from the supplied chunk.\n   * @param chunk - chunk to copy\n   * @param start - start index\n   * @param end - end index\n   * @returns a copy of a chunk slice\n   */\n  copy(chunk: Uint8Array, start: number, end: number): Uint8Array\n}\n\n// TextDecoder is available since node v8.3.0 and in all modern browsers\ndeclare class TextDecoder {\n  constructor(encoding: string)\n  decode(chunk: Uint8Array): string\n}\n\n/**\n * Creates a chunk combiner instance that uses UTF-8\n * TextDecoder to decode Uint8Arrays into strings.\n */\nexport function createTextDecoderCombiner(): ChunkCombiner {\n  const decoder = new TextDecoder('utf-8')\n  return {\n    concat(first: Uint8Array, second: Uint8Array): Uint8Array {\n      const retVal = new Uint8Array(first.length + second.length)\n      retVal.set(first)\n      retVal.set(second, first.length)\n      return retVal\n    },\n    copy(chunk: Uint8Array, start: number, end: number): Uint8Array {\n      const retVal = new Uint8Array(end - start)\n      retVal.set(chunk.subarray(start, end))\n      return retVal\n    },\n    toUtf8String(chunk: Uint8Array, start: number, end: number): string {\n      return decoder.decode(chunk.subarray(start, end))\n    },\n  }\n}\n","import {Transport} from './transport'\n\n/**\n * Option for the communication with InfluxDB server.\n */\nexport interface ConnectionOptions {\n  /** base host URL */\n  host: string\n  /** authentication token */\n  token?: string\n  /**\n   * socket timeout, 10000 milliseconds by default in node.js\n   * @defaultValue 10000\n   */\n  timeout?: number\n  /**\n   * default database for write query if not present as argument.\n   */\n  database?: string\n  /**\n   * TransportOptions supply extra options for the transport layer, they differ between node.js and browser/deno.\n   * Node.js transport accepts options specified in {@link https://nodejs.org/api/http.html#http_http_request_options_callback | http.request } or\n   * {@link https://nodejs.org/api/https.html#https_https_request_options_callback | https.request }. For example, an `agent` property can be set to\n   * {@link https://www.npmjs.com/package/proxy-http-agent | setup HTTP/HTTPS proxy }, {@link  https://nodejs.org/api/tls.html#tls_tls_connect_options_callback | rejectUnauthorized }\n   * property can disable TLS server certificate verification. Additionally,\n   * {@link https://github.com/follow-redirects/follow-redirects | follow-redirects } property can be also specified\n   * in order to follow redirects in node.js.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/fetch | fetch } is used under the hood in browser/deno.\n   * For example,\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/fetch | redirect } property can be set to 'error' to abort request if a redirect occurs.\n   */\n  transportOptions?: {[key: string]: any}\n  /**\n   * Default HTTP headers to send with every request.\n   */\n  headers?: Record<string, string>\n  /**\n   * Full HTTP web proxy URL including schema, for example http://your-proxy:8080.\n   */\n  proxyUrl?: string\n}\n\n/** default connection options */\nexport const DEFAULT_ConnectionOptions: Partial<ConnectionOptions> = {\n  timeout: 10000,\n}\n\n/**\n * Options used by {@link InfluxDBClient.write} .\n */\nexport interface WriteOptions {\n  /** Precision to use in writes for timestamp. default ns */\n  precision: WritePrecision\n  /** HTTP headers that will be sent with every write request */\n  headers?: {[key: string]: string}\n  /** When specified, write bodies larger than the threshold are gzipped  */\n  gzipThreshold?: number\n  /** InfluxDB Enterprise write consistency as explained in https://docs.influxdata.com/enterprise_influxdb/v1.9/concepts/clustering/#write-consistency */\n  consistency?: 'any' | 'one' | 'quorum' | 'all'\n}\n\n/** default writeOptions */\nexport const DEFAULT_WriteOptions: WriteOptions = {\n  precision: 'ns',\n  gzipThreshold: 1000,\n}\n\nexport type QueryType = 'sql' | 'influxql'\n\n/**\n * Options used by {@link InfluxDBClient} .\n */\nexport interface ClientOptions extends ConnectionOptions {\n  /** supplies and overrides default writing options */\n  writeOptions?: Partial<WriteOptions>\n  /** specifies custom transport */\n  transport?: Transport\n}\n\n/**\n * Timestamp precision used in write operations.\n * See {@link https://docs.influxdata.com/influxdb/latest/api/#operation/PostWrite }\n */\nexport type WritePrecision = 'ns' | 'us' | 'ms' | 's'\n","/**\n * Logging interface.\n */\nexport interface Logger {\n  error(message: string, err?: any): void\n  warn(message: string, err?: any): void\n}\n\n/**\n * Logger that logs to console.out\n */\nexport const consoleLogger: Logger = {\n  error(message, error) {\n    // eslint-disable-next-line no-console\n    console.error(`ERROR: ${message}`, error ? error : '')\n  },\n  warn(message, error) {\n    // eslint-disable-next-line no-console\n    console.warn(`WARN: ${message}`, error ? error : '')\n  },\n}\nlet provider: Logger = consoleLogger\n\nexport const Log: Logger = {\n  error(message, error) {\n    provider.error(message, error)\n  },\n  warn(message, error) {\n    provider.warn(message, error)\n  },\n}\n\n/**\n * Sets custom logger.\n * @param logger - logger to use\n * @returns previous logger\n */\nexport function setLogger(logger: Logger): Logger {\n  const previous = provider\n  provider = logger\n  return previous\n}\n","function createEscaper(\n  characters: string,\n  replacements: string[]\n): (value: string) => string {\n  return function (value: string): string {\n    let retVal = ''\n    let from = 0\n    let i = 0\n    while (i < value.length) {\n      const found = characters.indexOf(value[i])\n      if (found >= 0) {\n        retVal += value.substring(from, i)\n        retVal += replacements[found]\n        from = i + 1\n      }\n      i++\n    }\n    if (from == 0) {\n      return value\n    } else if (from < value.length) {\n      retVal += value.substring(from, value.length)\n    }\n    return retVal\n  }\n}\nfunction createQuotedEscaper(\n  characters: string,\n  replacements: string[]\n): (value: string) => string {\n  const escaper = createEscaper(characters, replacements)\n  return (value: string): string => `\"${escaper(value)}\"`\n}\n\n/**\n * Provides functions escape specific parts in InfluxDB line protocol.\n */\nexport const escape = {\n  /**\n   * Measurement escapes measurement names.\n   */\n  measurement: createEscaper(', \\n\\r\\t', ['\\\\,', '\\\\ ', '\\\\n', '\\\\r', '\\\\t']),\n  /**\n   * Quoted escapes quoted values, such as database names.\n   */\n  quoted: createQuotedEscaper('\"\\\\', ['\\\\\"', '\\\\\\\\']),\n\n  /**\n   * TagEscaper escapes tag keys, tag values, and field keys.\n   */\n  tag: createEscaper(', =\\n\\r\\t', ['\\\\,', '\\\\ ', '\\\\=', '\\\\n', '\\\\r', '\\\\t']),\n}\n","import {WritePrecision} from '../options'\n\ndeclare let process: any\nconst zeroPadding = '000000000'\nlet useHrTime = false\n\nexport function useProcessHrtime(use: boolean): boolean {\n  /* istanbul ignore else */\n  if (!process.env.BUILD_BROWSER) {\n    return (useHrTime = use && process && typeof process.hrtime === 'function')\n  } else {\n    return false\n  }\n}\nuseProcessHrtime(true) // preffer node\n\nlet startHrMillis: number | undefined = undefined\nlet startHrTime: [number, number] | undefined = undefined\nlet lastMillis = Date.now()\nlet stepsInMillis = 0\nfunction nanos(): string {\n  if (!process.env.BUILD_BROWSER && useHrTime) {\n    const hrTime = process.hrtime() as [number, number]\n    let millis = Date.now()\n    if (!startHrTime) {\n      startHrTime = hrTime\n      startHrMillis = millis\n    } else {\n      hrTime[0] = hrTime[0] - startHrTime[0]\n      hrTime[1] = hrTime[1] - startHrTime[1]\n      // istanbul ignore next \"cannot mock system clock, manually reviewed\"\n      if (hrTime[1] < 0) {\n        hrTime[0] -= 1\n        hrTime[1] += 1000_000_000\n      }\n      millis =\n        (startHrMillis as number) +\n        hrTime[0] * 1000 +\n        Math.floor(hrTime[1] / 1000_000)\n    }\n    const nanos = String(hrTime[1] % 1000_000)\n    return String(millis) + zeroPadding.substr(0, 6 - nanos.length) + nanos\n  } else {\n    const millis = Date.now()\n    if (millis !== lastMillis) {\n      lastMillis = millis\n      stepsInMillis = 0\n    } else {\n      stepsInMillis++\n    }\n    const nanos = String(stepsInMillis)\n    return String(millis) + zeroPadding.substr(0, 6 - nanos.length) + nanos\n  }\n}\n\nfunction micros(): string {\n  if (!process.env.BUILD_BROWSER && useHrTime) {\n    const hrTime = process.hrtime() as [number, number]\n    const micros = String(Math.trunc(hrTime[1] / 1000) % 1000)\n    return (\n      String(Date.now()) + zeroPadding.substr(0, 3 - micros.length) + micros\n    )\n  } else {\n    return String(Date.now()) + zeroPadding.substr(0, 3)\n  }\n}\nfunction millis(): string {\n  return String(Date.now())\n}\nfunction seconds(): string {\n  return String(Math.floor(Date.now() / 1000))\n}\n\n/**\n * Exposes functions that creates strings that represent a timestamp that\n * can be used in the line protocol. Micro and nano timestamps are emulated\n * depending on the js platform in use.\n */\nexport const currentTime = {\n  s: seconds as () => string,\n  ms: millis as () => string,\n  us: micros as () => string,\n  ns: nanos as () => string,\n  seconds: seconds as () => string,\n  millis: millis as () => string,\n  micros: micros as () => string,\n  nanos: nanos as () => string,\n}\n\n/**\n * dateToProtocolTimestamp provides converters for JavaScript Date to InfluxDB Write Protocol Timestamp. Keys are supported precisions.\n */\nexport const dateToProtocolTimestamp = {\n  s: (d: Date): string => `${Math.floor(d.getTime() / 1000)}`,\n  ms: (d: Date): string => `${d.getTime()}`,\n  us: (d: Date): string => `${d.getTime()}000`,\n  ns: (d: Date): string => `${d.getTime()}000000`,\n}\n\n/**\n * convertTimeToNanos converts Point's timestamp to a string.\n * @param value - supported timestamp value\n * @returns line protocol value\n */\nexport function convertTimeToNanos(\n  value: string | number | Date | undefined\n): string | undefined {\n  if (value === undefined) {\n    return nanos()\n  } else if (typeof value === 'string') {\n    return value.length > 0 ? value : undefined\n  } else if (value instanceof Date) {\n    return `${value.getTime()}000000`\n  } else if (typeof value === 'number') {\n    return String(Math.floor(value))\n  } else {\n    return String(value)\n  }\n}\n\nexport const convertTime = (\n  value: string | number | Date | undefined,\n  precision: WritePrecision = 'ns'\n): string | undefined => {\n  if (value === undefined) {\n    return currentTime[precision]()\n  } else if (typeof value === 'string') {\n    return value.length > 0 ? value : undefined\n  } else if (value instanceof Date) {\n    return dateToProtocolTimestamp[precision](value)\n  } else if (typeof value === 'number') {\n    return String(Math.floor(value))\n  } else {\n    return String(value)\n  }\n}\n","type Defined<T> = Exclude<T, undefined>\n\n/**\n * allows to throw error as expression\n */\nexport const throwReturn = <T>(err: Error): Defined<T> => {\n  throw err\n}\n\nexport const isDefined = <T>(value: T): value is Defined<T> =>\n  value !== undefined\n\nexport const isArrayLike = <T>(value: any): value is ArrayLike<T> =>\n  value instanceof Array ||\n  (value instanceof Object &&\n    typeof value.length === 'number' &&\n    (value.length === 0 ||\n      Object.getOwnPropertyNames(value).some((x) => x === '0')))\n\nexport const createInt32Uint8Array = (value: number): Uint8Array => {\n  const bytes = new Uint8Array(4)\n  bytes[0] = value >> (8 * 0)\n  bytes[1] = value >> (8 * 1)\n  bytes[2] = value >> (8 * 2)\n  bytes[3] = value >> (8 * 3)\n  return bytes\n}\n\nexport const collectAll = async <T>(\n  generator: AsyncGenerator<T, any, any>\n): Promise<T[]> => {\n  const results: T[] = []\n  for await (const value of generator) {\n    results.push(value)\n  }\n  return results\n}\n","import {Point} from '../Point'\nimport {isArrayLike, isDefined} from './common'\n\n/**\n * The `WritableData` type represents different types of data that can be written.\n * The data can either be a uniform ArrayLike collection or a single value of the following types:\n *\n * - `Point`: Represents a {@link Point} object.\n *\n * - `string`: Represents lines of the [Line Protocol](https://bit.ly/2QL99fu).\n */\nexport type WritableData = ArrayLike<string> | ArrayLike<Point> | string | Point\n\nexport const writableDataToLineProtocol = (data: WritableData): string[] => {\n  const arrayData = (\n    isArrayLike(data) && typeof data !== 'string'\n      ? Array.from(data as any)\n      : [data]\n  ) as string[] | Point[]\n  if (arrayData.length === 0) return []\n\n  const isLine = typeof arrayData[0] === 'string'\n\n  return isLine\n    ? (arrayData as string[])\n    : (arrayData as Point[]).map((p) => p.toLineProtocol()).filter(isDefined)\n}\n","import {Point} from './Point'\n\nexport type PointFieldType =\n  | 'float'\n  | 'integer'\n  | 'uinteger'\n  | 'string'\n  | 'boolean'\n\ntype FieldEntryFloat = ['float', number]\ntype FieldEntryInteger = ['integer', number]\ntype FieldEntryUinteger = ['uinteger', number]\ntype FieldEntryString = ['string', string]\ntype FieldEntryBoolean = ['boolean', boolean]\n\ntype FieldEntry =\n  | FieldEntryFloat\n  | FieldEntryInteger\n  | FieldEntryUinteger\n  | FieldEntryString\n  | FieldEntryBoolean\n\nconst inferType = (\n  value: number | string | boolean | undefined\n): PointFieldType | undefined => {\n  if (typeof value === 'number') return 'float'\n  else if (typeof value === 'string') return 'string'\n  else if (typeof value === 'boolean') return 'boolean'\n  else return undefined\n}\n\nexport class GetFieldTypeMissmatchError extends Error {\n  /* istanbul ignore next */\n  constructor(\n    fieldName: string,\n    expectedType: PointFieldType,\n    actualType: PointFieldType\n  ) {\n    super(\n      `field ${fieldName} of type ${actualType} doesn't match expected type ${expectedType}!`\n    )\n    this.name = 'GetFieldTypeMissmatchError'\n    Object.setPrototypeOf(this, GetFieldTypeMissmatchError.prototype)\n  }\n}\n\n/**\n * Point defines values of a single measurement.\n */\nexport class PointValues {\n  private _name: string | undefined\n  private _time: string | number | Date | undefined\n  private _tags: {[key: string]: string} = {}\n  private _fields: {[key: string]: FieldEntry} = {}\n\n  /**\n   * Create an empty PointValues.\n   */\n  constructor() {}\n\n  /**\n   * Get measurement name. Can be undefined if not set.\n   *\n   * @returns measurement name or undefined\n   */\n  getMeasurement(): string | undefined {\n    return this._name\n  }\n\n  /**\n   * Sets point's measurement.\n   *\n   * @param name - measurement name\n   * @returns this\n   */\n  public setMeasurement(name: string): PointValues {\n    this._name = name\n    return this\n  }\n\n  /**\n   * Get timestamp. Can be undefined if not set.\n   *\n   * @returns timestamp or undefined\n   */\n  public getTimestamp(): Date | number | string | undefined {\n    return this._time\n  }\n\n  /**\n   * Sets point timestamp. Timestamp can be specified as a Date (preferred), number, string\n   * or an undefined value. An undefined value instructs to assign a local timestamp using\n   * the client's clock. An empty string can be used to let the server assign\n   * the timestamp. A number value represents time as a count of time units since epoch, the\n   * exact time unit then depends on the {@link InfluxDBClient.write | precision} of the API\n   * that writes the point.\n   *\n   * Beware that the current time in nanoseconds can't precisely fit into a JS number,\n   * which can hold at most 2^53 integer number. Nanosecond precision numbers are thus supplied as\n   * a (base-10) string. An application can also use ES2020 BigInt to represent nanoseconds,\n   * BigInt's `toString()` returns the required high-precision string.\n   *\n   * Note that InfluxDB requires the timestamp to fit into int64 data type.\n   *\n   * @param value - point time\n   * @returns this\n   */\n  public setTimestamp(value: Date | number | string | undefined): PointValues {\n    this._time = value\n    return this\n  }\n\n  /**\n   * Gets value of tag with given name. Returns undefined if tag not found.\n   *\n   * @param name - tag name\n   * @returns tag value or undefined\n   */\n  public getTag(name: string): string | undefined {\n    return this._tags[name]\n  }\n\n  /**\n   * Sets a tag. The caller has to ensure that both name and value are not empty\n   * and do not end with backslash.\n   *\n   * @param name - tag name\n   * @param value - tag value\n   * @returns this\n   */\n  public setTag(name: string, value: string): PointValues {\n    this._tags[name] = value\n    return this\n  }\n\n  /**\n   * Removes a tag with the specified name if it exists; otherwise, it does nothing.\n   *\n   * @param name - The name of the tag to be removed.\n   * @returns this\n   */\n  public removeTag(name: string): PointValues {\n    delete this._tags[name]\n    return this\n  }\n\n  /**\n   * Gets an array of tag names.\n   *\n   * @returns An array of tag names.\n   */\n  public getTagNames(): string[] {\n    return Object.keys(this._tags)\n  }\n\n  /**\n   * Gets the float field value associated with the specified name.\n   * Throws if actual type of field with given name is not float.\n   * If the field is not present, returns undefined.\n   *\n   * @param name - field name\n   * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match float type.\n   * @returns The float field value or undefined.\n   */\n  public getFloatField(name: string): number | undefined {\n    return this.getField(name, 'float')\n  }\n\n  /**\n   * Sets a number field.\n   *\n   * @param name - field name\n   * @param value - field value\n   * @returns this\n   * @throws NaN/Infinity/-Infinity is supplied\n   */\n  public setFloatField(name: string, value: number | any): PointValues {\n    let val: number\n    if (typeof value === 'number') {\n      val = value\n    } else {\n      val = parseFloat(value)\n    }\n    if (!isFinite(val)) {\n      throw new Error(`invalid float value for field '${name}': '${value}'!`)\n    }\n\n    this._fields[name] = ['float', val]\n    return this\n  }\n\n  /**\n   * Gets the integer field value associated with the specified name.\n   * Throws if actual type of field with given name is not integer.\n   * If the field is not present, returns undefined.\n   *\n   * @param name - field name\n   * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match integer type.\n   * @returns The integer field value or undefined.\n   */\n  public getIntegerField(name: string): number | undefined {\n    return this.getField(name, 'integer')\n  }\n\n  /**\n   * Sets an integer field.\n   *\n   * @param name - field name\n   * @param value - field value\n   * @returns this\n   * @throws NaN or out of int64 range value is supplied\n   */\n  public setIntegerField(name: string, value: number | any): PointValues {\n    let val: number\n    if (typeof value === 'number') {\n      val = value\n    } else {\n      val = parseInt(String(value))\n    }\n    if (isNaN(val) || val <= -9223372036854776e3 || val >= 9223372036854776e3) {\n      throw new Error(`invalid integer value for field '${name}': '${value}'!`)\n    }\n    this._fields[name] = ['integer', Math.floor(val)]\n    return this\n  }\n\n  /**\n   * Gets the uint field value associated with the specified name.\n   * Throws if actual type of field with given name is not uint.\n   * If the field is not present, returns undefined.\n   *\n   * @param name - field name\n   * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match uint type.\n   * @returns The uint field value or undefined.\n   */\n  public getUintegerField(name: string): number | undefined {\n    return this.getField(name, 'uinteger')\n  }\n\n  /**\n   * Sets an unsigned integer field.\n   *\n   * @param name - field name\n   * @param value - field value\n   * @returns this\n   * @throws NaN out of range value is supplied\n   */\n  public setUintegerField(name: string, value: number | any): PointValues {\n    if (typeof value === 'number') {\n      if (isNaN(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {\n        throw new Error(`uint value for field '${name}' out of range: ${value}`)\n      }\n      this._fields[name] = ['uinteger', Math.floor(value as number)]\n    } else {\n      const strVal = String(value)\n      for (let i = 0; i < strVal.length; i++) {\n        const code = strVal.charCodeAt(i)\n        if (code < 48 || code > 57) {\n          throw new Error(\n            `uint value has an unsupported character at pos ${i}: ${value}`\n          )\n        }\n      }\n      if (\n        strVal.length > 20 ||\n        (strVal.length === 20 &&\n          strVal.localeCompare('18446744073709551615') > 0)\n      ) {\n        throw new Error(\n          `uint value for field '${name}' out of range: ${strVal}`\n        )\n      }\n      this._fields[name] = ['uinteger', +strVal]\n    }\n    return this\n  }\n\n  /**\n   * Gets the string field value associated with the specified name.\n   * Throws if actual type of field with given name is not string.\n   * If the field is not present, returns undefined.\n   *\n   * @param name - field name\n   * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match string type.\n   * @returns The string field value or undefined.\n   */\n  public getStringField(name: string): string | undefined {\n    return this.getField(name, 'string')\n  }\n\n  /**\n   * Sets a string field.\n   *\n   * @param name - field name\n   * @param value - field value\n   * @returns this\n   */\n  public setStringField(name: string, value: string | any): PointValues {\n    if (value !== null && value !== undefined) {\n      if (typeof value !== 'string') value = String(value)\n      this._fields[name] = ['string', value]\n    }\n    return this\n  }\n\n  /**\n   * Gets the boolean field value associated with the specified name.\n   * Throws if actual type of field with given name is not boolean.\n   * If the field is not present, returns undefined.\n   *\n   * @param name - field name\n   * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match boolean type.\n   * @returns The boolean field value or undefined.\n   */\n  public getBooleanField(name: string): boolean | undefined {\n    return this.getField(name, 'boolean')\n  }\n\n  /**\n   * Sets a boolean field.\n   *\n   * @param name - field name\n   * @param value - field value\n   * @returns this\n   */\n  public setBooleanField(name: string, value: boolean | any): PointValues {\n    this._fields[name] = ['boolean', !!value]\n    return this\n  }\n\n  /**\n   * Get field of numeric type.\n   * Throws if actual type of field with given name is not given numeric type.\n   * If the field is not present, returns undefined.\n   *\n   * @param name - field name\n   * @param type - field numeric type\n   * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match provided numeric type.\n   * @returns this\n   */\n  public getField(\n    name: string,\n    type: 'float' | 'integer' | 'uinteger'\n  ): number | undefined\n  /**\n   * Get field of string type.\n   * Throws if actual type of field with given name is not string.\n   * If the field is not present, returns undefined.\n   *\n   * @param name - field name\n   * @param type - field string type\n   * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match provided 'string' type.\n   * @returns this\n   */\n  public getField(name: string, type: 'string'): string | undefined\n  /**\n   * Get field of boolean type.\n   * Throws if actual type of field with given name is not boolean.\n   * If the field is not present, returns undefined.\n   *\n   * @param name - field name\n   * @param type - field boolean type\n   * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match provided 'boolean' type.\n   * @returns this\n   */\n  public getField(name: string, type: 'boolean'): boolean | undefined\n  /**\n   * Get field without type check.\n   * If the field is not present, returns undefined.\n   *\n   * @param name - field name\n   * @returns this\n   */\n  public getField(name: string): number | string | boolean | undefined\n  public getField(\n    name: string,\n    type?: PointFieldType\n  ): number | string | boolean | undefined {\n    const fieldEntry = this._fields[name]\n    if (!fieldEntry) return undefined\n    const [actualType, value] = fieldEntry\n    if (type !== undefined && type !== actualType)\n      throw new GetFieldTypeMissmatchError(name, type, actualType)\n    return value\n  }\n\n  /**\n   * Gets the type of field with given name, if it exists.\n   * If the field is not present, returns undefined.\n   *\n   * @param name - field name\n   * @returns The field type or undefined.\n   */\n  public getFieldType(name: string): PointFieldType | undefined {\n    const fieldEntry = this._fields[name]\n    if (!fieldEntry) return undefined\n    return fieldEntry[0]\n  }\n\n  /**\n   * Sets field based on provided type.\n   *\n   * @param name - field name\n   * @param value - field value\n   * @param type - field type\n   * @returns this\n   */\n  public setField(\n    name: string,\n    value: any,\n    type?: PointFieldType\n  ): PointValues {\n    const inferedType = type ?? inferType(value)\n    switch (inferedType) {\n      case 'string':\n        return this.setStringField(name, value)\n      case 'boolean':\n        return this.setBooleanField(name, value)\n      case 'float':\n        return this.setFloatField(name, value)\n      case 'integer':\n        return this.setIntegerField(name, value)\n      case 'uinteger':\n        return this.setUintegerField(name, value)\n      case undefined:\n        return this\n      default:\n        throw new Error(\n          `invalid field type for field '${name}': type -> ${type}, value -> ${value}!`\n        )\n    }\n  }\n\n  /**\n   * Add fields according to their type. All numeric type is considered float\n   *\n   * @param fields - name-value map\n   * @returns this\n   */\n  public setFields(fields: {\n    [key: string]: number | boolean | string\n  }): PointValues {\n    for (const [name, value] of Object.entries(fields)) {\n      this.setField(name, value)\n    }\n    return this\n  }\n\n  /**\n   * Removes a field with the specified name if it exists; otherwise, it does nothing.\n   *\n   * @param name - The name of the field to be removed.\n   * @returns this\n   */\n  public removeField(name: string): PointValues {\n    delete this._fields[name]\n    return this\n  }\n\n  /**\n   * Gets an array of field names associated with this object.\n   *\n   * @returns An array of field names.\n   */\n  public getFieldNames(): string[] {\n    return Object.keys(this._fields)\n  }\n\n  /**\n   * Checks if this object has any fields.\n   *\n   * @returns true if fields are present, false otherwise.\n   */\n  public hasFields(): boolean {\n    return this.getFieldNames().length > 0\n  }\n\n  /**\n   * Creates a copy of this object.\n   *\n   * @returns A new instance with same values.\n   */\n  copy(): PointValues {\n    const copy = new PointValues()\n    copy._name = this._name\n    copy._time = this._time\n    copy._tags = Object.fromEntries(Object.entries(this._tags))\n    copy._fields = Object.fromEntries(\n      Object.entries(this._fields).map((entry) => [...entry])\n    )\n    return copy\n  }\n\n  /**\n   * Creates new Point with this as values.\n   *\n   * @returns Point from this values.\n   */\n  public asPoint(measurement?: string): Point {\n    return Point.fromValues(\n      measurement ? this.setMeasurement(measurement) : this\n    )\n  }\n}\n","import {TimeConverter} from './WriteApi'\nimport {convertTimeToNanos, convertTime} from './util/time'\nimport {escape} from './util/escape'\nimport {WritePrecision} from './options'\nimport {PointFieldType, PointValues} from './PointValues'\n\nconst fieldToLPString: {\n  (type: 'float', value: number): string\n  (type: 'integer', value: number): string\n  (type: 'uinteger', value: number): string\n  (type: 'string', value: string): string\n  (type: 'boolean', value: boolean): string\n  (type: PointFieldType, value: number | string | boolean): string\n} = (type: PointFieldType, value: number | string | boolean): string => {\n  switch (type) {\n    case 'string':\n      return escape.quoted(value as string)\n    case 'boolean':\n      return value ? 'T' : 'F'\n    case 'float':\n      return `${value}`\n    case 'integer':\n      return `${value}i`\n    case 'uinteger':\n      return `${value}u`\n  }\n}\n\n/**\n * Point defines values of a single measurement.\n */\nexport class Point {\n  private readonly _values: PointValues\n\n  /**\n   * Create a new Point with specified a measurement name.\n   *\n   * @param measurementName - the measurement name\n   */\n  private constructor(measurementName: string)\n  /**\n   * Create a new Point with given values.\n   * After creating Point, it's values shouldn't be modified directly by PointValues object.\n   *\n   * @param values - point values\n   */\n  private constructor(values: PointValues)\n  private constructor(arg0?: PointValues | string) {\n    if (arg0 instanceof PointValues) {\n      this._values = arg0\n    } else {\n      this._values = new PointValues()\n    }\n\n    if (typeof arg0 === 'string') this._values.setMeasurement(arg0)\n  }\n\n  /**\n   * Creates new Point with given measurement.\n   *\n   * @param name - measurement name\n   * @returns new Point\n   */\n  public static measurement(name: string): Point {\n    return new Point(name)\n  }\n\n  /**\n   * Creates new point from PointValues object.\n   * Can throw error if measurement missing.\n   *\n   * @param values - point values object with measurement\n   * @throws missing measurement\n   * @returns new point from values\n   */\n  public static fromValues(values: PointValues): Point {\n    if (!values.getMeasurement() || values.getMeasurement() === '') {\n      throw new Error('Cannot convert values to point without measurement set!')\n    }\n    return new Point(values)\n  }\n\n  /**\n   * Get measurement name.\n   *\n   * @returns measurement name\n   */\n  public getMeasurement(): string {\n    return this._values.getMeasurement() as string\n  }\n\n  /**\n   * Sets point's measurement.\n   *\n   * @param name - measurement name\n   * @returns this\n   */\n  public setMeasurement(name: string): Point {\n    if (name !== '') {\n      this._values.setMeasurement(name)\n    }\n    return this\n  }\n\n  /**\n   * Get timestamp. Can be undefined if not set.\n   *\n   * @returns timestamp or undefined\n   */\n  public getTimestamp(): Date | number | string | undefined {\n    return this._values.getTimestamp()\n  }\n\n  /**\n   * Sets point timestamp. Timestamp can be specified as a Date (preferred), number, string\n   * or an undefined value. An undefined value instructs to assign a local timestamp using\n   * the client's clock. An empty string can be used to let the server assign\n   * the timestamp. A number value represents time as a count of time units since epoch, the\n   * exact time unit then depends on the {@link InfluxDBClient.write | precision} of the API\n   * that writes the point.\n   *\n   * Beware that the current time in nanoseconds can't precisely fit into a JS number,\n   * which can hold at most 2^53 integer number. Nanosecond precision numbers are thus supplied as\n   * a (base-10) string. An application can also use ES2020 BigInt to represent nanoseconds,\n   * BigInt's `toString()` returns the required high-precision string.\n   *\n   * Note that InfluxDB requires the timestamp to fit into int64 data type.\n   *\n   * @param value - point time\n   * @returns this\n   */\n  public setTimestamp(value: Date | number | string | undefined): Point {\n    this._values.setTimestamp(value)\n    return this\n  }\n\n  /**\n   * Gets value of tag with given name. Returns undefined if tag not found.\n   *\n   * @param name - tag name\n   * @returns tag value or undefined\n   */\n  public getTag(name: string): string | undefined {\n    return this._values.getTag(name)\n  }\n\n  /**\n   * Sets a tag. The caller has to ensure that both name and value are not empty\n   * and do not end with backslash.\n   *\n   * @param name - tag name\n   * @param value - tag value\n   * @returns this\n   */\n  public setTag(name: string, value: string): Point {\n    this._values.setTag(name, value)\n    return this\n  }\n\n  /**\n   * Removes a tag with the specified name if it exists; otherwise, it does nothing.\n   *\n   * @param name - The name of the tag to be removed.\n   * @returns this\n   */\n  public removeTag(name: string): Point {\n    this._values.removeTag(name)\n    return this\n  }\n\n  /**\n   * Gets an array of tag names.\n   *\n   * @returns An array of tag names.\n   */\n  public getTagNames(): string[] {\n    return this._values.getTagNames()\n  }\n\n  /**\n   * Gets the float field value associated with the specified name.\n   * Throws if actual type of field with given name is not float.\n   * If the field is not present, returns undefined.\n   *\n   * @param name - field name\n   * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match float type.\n   * @returns The float field value or undefined.\n   */\n  public getFloatField(name: string): number | undefined {\n    return this._values.getFloatField(name)\n  }\n\n  /**\n   * Sets a number field.\n   *\n   * @param name - field name\n   * @param value - field value\n   * @returns this\n   * @throws NaN/Infinity/-Infinity is supplied\n   */\n  public setFloatField(name: string, value: number | any): Point {\n    this._values.setFloatField(name, value)\n    return this\n  }\n\n  /**\n   * Gets the integer field value associated with the specified name.\n   * Throws if actual type of field with given name is not integer.\n   * If the field is not present, returns undefined.\n   *\n   * @param name - field name\n   * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match integer type.\n   * @returns The integer field value or undefined.\n   */\n  public getIntegerField(name: string): number | undefined {\n    return this._values.getIntegerField(name)\n  }\n\n  /**\n   * Sets an integer field.\n   *\n   * @param name - field name\n   * @param value - field value\n   * @returns this\n   * @throws NaN or out of int64 range value is supplied\n   */\n  public setIntegerField(name: string, value: number | any): Point {\n    this._values.setIntegerField(name, value)\n    return this\n  }\n\n  /**\n   * Gets the uint field value associated with the specified name.\n   * Throws if actual type of field with given name is not uint.\n   * If the field is not present, returns undefined.\n   *\n   * @param name - field name\n   * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match uint type.\n   * @returns The uint field value or undefined.\n   */\n  public getUintegerField(name: string): number | undefined {\n    return this._values.getUintegerField(name)\n  }\n\n  /**\n   * Sets an unsigned integer field.\n   *\n   * @param name - field name\n   * @param value - field value\n   * @returns this\n   * @throws NaN out of range value is supplied\n   */\n  public setUintegerField(name: string, value: number | any): Point {\n    this._values.setUintegerField(name, value)\n    return this\n  }\n\n  /**\n   * Gets the string field value associated with the specified name.\n   * Throws if actual type of field with given name is not string.\n   * If the field is not present, returns undefined.\n   *\n   * @param name - field name\n   * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match string type.\n   * @returns The string field value or undefined.\n   */\n  public getStringField(name: string): string | undefined {\n    return this._values.getStringField(name)\n  }\n\n  /**\n   * Sets a string field.\n   *\n   * @param name - field name\n   * @param value - field value\n   * @returns this\n   */\n  public setStringField(name: string, value: string | any): Point {\n    this._values.setStringField(name, value)\n    return this\n  }\n\n  /**\n   * Gets the boolean field value associated with the specified name.\n   * Throws if actual type of field with given name is not boolean.\n   * If the field is not present, returns undefined.\n   *\n   * @param name - field name\n   * @throws {@link GetFieldTypeMissmatchError} Actual type of field doesn't match boolean type.\n   * @returns The boolean field value or undefined.\n   */\n  public getBooleanField(name: string): boolean | undefined {\n    return this._values.getBooleanField(name)\n  }\n\n  /**\n   * Sets a boolean field.\n   *\n   * @param name - field name\n   * @param value - field value\n   * @returns this\n   */\n  public setBooleanField(name: string, value: boolean | any): Point {\n    this._values.setBooleanField(name, value)\n    return this\n  }\n\n  /**\n   * Get field of numeric type.\n   *\n   * @param name - field name\n   * @param type - field numeric type\n   * @throws Field type doesn't match actual type\n   * @returns this\n   */\n  public getField(\n    name: string,\n    type: 'float' | 'integer' | 'uinteger'\n  ): number | undefined\n  /**\n   * Get field of string type.\n   *\n   * @param name - field name\n   * @param type - field string type\n   * @throws Field type doesn't match actual type\n   * @returns this\n   */\n  public getField(name: string, type: 'string'): string | undefined\n  /**\n   * Get field of boolean type.\n   *\n   * @param name - field name\n   * @param type - field boolean type\n   * @throws Field type doesn't match actual type\n   * @returns this\n   */\n  public getField(name: string, type: 'boolean'): boolean | undefined\n  /**\n   * Get field without type check.\n   *\n   * @param name - field name\n   * @returns this\n   */\n  public getField(name: string): number | string | boolean | undefined\n  public getField(\n    name: string,\n    type?: PointFieldType\n  ): number | string | boolean | undefined {\n    return this._values.getField(name, type as any)\n  }\n\n  /**\n   * Gets the type of field with given name, if it exists.\n   * If the field is not present, returns undefined.\n   *\n   * @param name - field name\n   * @returns The field type or undefined.\n   */\n  public getFieldType(name: string): PointFieldType | undefined {\n    return this._values.getFieldType(name)\n  }\n\n  /**\n   * Sets field based on provided type.\n   *\n   * @param name - field name\n   * @param value - field value\n   * @param type - field type\n   * @returns this\n   */\n  public setField(name: string, value: any, type?: PointFieldType): Point {\n    this._values.setField(name, value, type)\n    return this\n  }\n\n  /**\n   * Add fields according to their type. All numeric type is considered float\n   *\n   * @param fields - name-value map\n   * @returns this\n   */\n  public setFields(fields: {[key: string]: number | boolean | string}): Point {\n    this._values.setFields(fields)\n    return this\n  }\n\n  /**\n   * Removes a field with the specified name if it exists; otherwise, it does nothing.\n   *\n   * @param name - The name of the field to be removed.\n   * @returns this\n   */\n  public removeField(name: string): Point {\n    this._values.removeField(name)\n    return this\n  }\n\n  /**\n   * Gets an array of field names associated with this object.\n   *\n   * @returns An array of field names.\n   */\n  public getFieldNames(): string[] {\n    return this._values.getFieldNames()\n  }\n\n  /**\n   * Checks if this object has any fields.\n   *\n   * @returns true if fields are present, false otherwise.\n   */\n  public hasFields(): boolean {\n    return this._values.hasFields()\n  }\n\n  /**\n   * Creates a copy of this object.\n   *\n   * @returns A new instance with same values.\n   */\n  copy(): Point {\n    return new Point(this._values.copy())\n  }\n\n  /**\n   * Creates an InfluxDB protocol line out of this instance.\n   * @param convertTimePrecision - settings control serialization of a point timestamp and can also add default tags,\n   * nanosecond timestamp precision is used when no `settings` or no `settings.convertTime` is supplied.\n   * @returns an InfluxDB protocol line out of this instance\n   */\n  public toLineProtocol(\n    convertTimePrecision?: TimeConverter | WritePrecision\n  ): string | undefined {\n    if (!this._values.getMeasurement()) return undefined\n    let fieldsLine = ''\n    this._values\n      .getFieldNames()\n      .sort()\n      .forEach((name) => {\n        if (name) {\n          const type = this._values.getFieldType(name)\n          const value = this._values.getField(name)\n          if (type === undefined || value === undefined) return\n          const lpStringValue = fieldToLPString(type, value)\n          if (fieldsLine.length > 0) fieldsLine += ','\n          fieldsLine += `${escape.tag(name)}=${lpStringValue}`\n        }\n      })\n    if (fieldsLine.length === 0) return undefined // no fields present\n    let tagsLine = ''\n    const tagNames = this._values.getTagNames()\n    tagNames.sort().forEach((x) => {\n      if (x) {\n        const val = this._values.getTag(x)\n        if (val) {\n          tagsLine += ','\n          tagsLine += `${escape.tag(x)}=${escape.tag(val)}`\n        }\n      }\n    })\n    let time = this._values.getTimestamp()\n\n    if (!convertTimePrecision) {\n      time = convertTimeToNanos(time)\n    } else if (typeof convertTimePrecision === 'string')\n      time = convertTime(time, convertTimePrecision)\n    else {\n      time = convertTimePrecision(time)\n    }\n\n    return `${escape.measurement(\n      this.getMeasurement()\n    )}${tagsLine} ${fieldsLine}${time !== undefined ? ` ${time}` : ''}`\n  }\n\n  toString(): string {\n    const line = this.toLineProtocol(undefined)\n    return line ? line : `invalid point: ${JSON.stringify(this, undefined)}`\n  }\n}\n","import {parse} from 'url'\nimport * as http from 'http'\nimport * as https from 'https'\nimport {Buffer} from 'buffer'\nimport {RequestTimedOutError, AbortError, HttpError} from '../../errors'\nimport {Transport, SendOptions} from '../../transport'\nimport {\n  Cancellable,\n  CommunicationObserver,\n  Headers,\n  ResponseStartedFn,\n} from '../../results'\nimport zlib from 'zlib'\nimport completeCommunicationObserver from '../completeCommunicationObserver'\nimport {CLIENT_LIB_VERSION} from '../version'\nimport {Log} from '../../util/logger'\nimport {pipeline, Readable} from 'stream'\nimport {ConnectionOptions, DEFAULT_ConnectionOptions} from '../../options'\n\nconst zlibOptions = {\n  flush: zlib.constants.Z_SYNC_FLUSH,\n  finishFlush: zlib.constants.Z_SYNC_FLUSH,\n}\nconst emptyBuffer = Buffer.allocUnsafe(0)\n\nclass CancellableImpl implements Cancellable {\n  private _cancelled = false\n  public resume?: () => void\n  cancel(): void {\n    this._cancelled = true\n    if (this.resume) {\n      this.resume()\n      this.resume = undefined\n    }\n  }\n  isCancelled(): boolean {\n    return this._cancelled\n  }\n}\n\n/**\n * Transport layer on top of node http or https library.\n */\nexport class NodeHttpTransport implements Transport {\n  private _defaultOptions: {[key: string]: any}\n  private _requestApi: (\n    options: http.RequestOptions,\n    callback: (res: http.IncomingMessage) => void\n  ) => http.ClientRequest\n  private _contextPath: string\n  private _token?: string\n  private _headers: Record<string, string>\n  /**\n   * Creates a node transport using for the client options supplied.\n   * @param connectionOptions - connection options\n   */\n  constructor(connectionOptions: ConnectionOptions) {\n    const {\n      host: _url,\n      proxyUrl,\n      token,\n      transportOptions,\n      ...nodeSupportedOptions\n    } = connectionOptions\n    const url = parse(proxyUrl || _url)\n    this._token = token\n    this._defaultOptions = {\n      ...DEFAULT_ConnectionOptions,\n      ...nodeSupportedOptions,\n      ...transportOptions,\n      port: url.port,\n      protocol: url.protocol,\n      hostname: url.hostname,\n    }\n    this._contextPath = proxyUrl ? _url : url.path ?? ''\n    if (this._contextPath.endsWith('/')) {\n      this._contextPath = this._contextPath.substring(\n        0,\n        this._contextPath.length - 1\n      )\n    }\n    // remove all undefined field to avoid node validation errors\n    // https://github.com/influxdata/influxdb-client-js/issues/380\n    Object.keys(this._defaultOptions).forEach(\n      (key) =>\n        this._defaultOptions[key] === undefined &&\n        delete this._defaultOptions[key]\n    )\n    // https://github.com/influxdata/influxdb-client-js/issues/263\n    // don't allow /api/v2 suffix to avoid future problems\n    if (this._contextPath.endsWith('/api/v2')) {\n      Log.warn(\n        `Please remove '/api/v2' context path from InfluxDB base url, using ${url.protocol}//${url.hostname}:${url.port} !`\n      )\n      this._contextPath = ''\n    }\n\n    if (url.protocol === 'http:') {\n      this._requestApi =\n        this._defaultOptions['follow-redirects']?.http?.request ?? http.request\n    } else if (url.protocol === 'https:') {\n      this._requestApi =\n        this._defaultOptions['follow-redirects']?.https?.request ??\n        https.request\n    } else {\n      throw new Error(\n        `Unsupported protocol \"${url.protocol} in URL: \"${connectionOptions.host}\"`\n      )\n    }\n    this._headers = {\n      'User-Agent': `influxdb-client-js/${CLIENT_LIB_VERSION}`,\n      ...connectionOptions.headers,\n    }\n    if (proxyUrl) {\n      this._headers['Host'] = parse(_url).host as string\n    }\n  }\n\n  /**\n   * Sends data to server and receives communication events via communication callbacks.\n   *\n   * @param path - HTTP request  path\n   * @param body - message body\n   * @param headers - HTTP headers\n   * @param method - HTTP method\n   * @param callbacks - communication callbacks\n   */\n  send(\n    path: string,\n    body: string,\n    options: SendOptions,\n    callbacks?: Partial<CommunicationObserver<any>>\n  ): void {\n    const cancellable = new CancellableImpl()\n    if (callbacks && callbacks.useCancellable)\n      callbacks.useCancellable(cancellable)\n    this._createRequestMessage(\n      path,\n      body,\n      options,\n      (message: {[key: string]: any}) => {\n        this._request(message, cancellable, callbacks)\n      },\n      /* istanbul ignore next - hard to simulate failure, manually reviewed */\n      (err: Error) => callbacks?.error && callbacks.error(err)\n    )\n  }\n\n  /**\n   * Sends data to the server and receives decoded result. The type of the result depends on\n   * response's content-type (deserialized json, text).\n\n   * @param path - HTTP path\n   * @param requestBody - request body\n   * @param options - send options\n   * @returns Promise of response body\n   */\n  request(\n    path: string,\n    body: any,\n    options: SendOptions,\n    responseStarted?: ResponseStartedFn\n  ): Promise<any> {\n    if (!body) {\n      body = ''\n    } else if (typeof body !== 'string') {\n      body = JSON.stringify(body)\n    }\n    let buffer = emptyBuffer\n    let contentType: string\n    let responseStatusCode: number | undefined\n    return new Promise((resolve, reject) => {\n      this.send(path, body as string, options, {\n        responseStarted(headers: Headers, statusCode?: number) {\n          if (responseStarted) {\n            responseStarted(headers, statusCode)\n          }\n          contentType = String(headers['content-type'])\n          responseStatusCode = statusCode\n        },\n        next: (data: Uint8Array): void => {\n          buffer = Buffer.concat([buffer, data])\n        },\n        complete: (): void => {\n          const responseType = options.headers?.accept ?? contentType\n          try {\n            if (responseStatusCode === 204) {\n              // ignore body of NO_CONTENT response\n              resolve(undefined)\n            }\n            if (responseType.includes('json')) {\n              if (buffer.length) {\n                resolve(JSON.parse(buffer.toString('utf8')))\n              } else {\n                resolve(undefined)\n              }\n            } else if (\n              responseType.includes('text') ||\n              responseType.startsWith('application/csv')\n            ) {\n              resolve(buffer.toString('utf8'))\n            } else {\n              resolve(buffer)\n            }\n          } catch (e) {\n            reject(e)\n          }\n        },\n        error: (e: Error): void => {\n          reject(e)\n        },\n      })\n    })\n  }\n\n  async *iterate(\n    path: string,\n    body: string,\n    options: SendOptions\n  ): AsyncIterableIterator<Uint8Array> {\n    let terminationError: Error | undefined = undefined\n    let nestedReject: (e: Error) => void\n    function wrapReject(error: Error) {\n      terminationError = error\n      nestedReject(error)\n    }\n    const requestMessage = await new Promise<Record<string, any>>(\n      (resolve, reject) => {\n        nestedReject = reject\n        this._createRequestMessage(path, body, options, resolve, wrapReject)\n      }\n    )\n    if (requestMessage.signal?.addEventListener) {\n      ;(requestMessage.signal as AbortSignal).addEventListener('abort', () => {\n        wrapReject(new AbortError())\n      })\n    }\n    const response = await new Promise<http.IncomingMessage>(\n      (resolve, reject) => {\n        nestedReject = reject\n        const req = this._requestApi(requestMessage, resolve)\n        req.on('timeout', () => wrapReject(new RequestTimedOutError()))\n        req.on('error', wrapReject)\n\n        req.write(requestMessage.body)\n        req.end()\n      }\n    )\n    const res = await new Promise<Readable>((resolve, reject) => {\n      nestedReject = reject\n      this._prepareResponse(response, resolve, wrapReject)\n    })\n    for await (const chunk of res) {\n      if (terminationError) {\n        throw terminationError\n      }\n      yield chunk\n    }\n  }\n  /**\n   * Creates configuration for a specific request.\n   *\n   * @param path - API path starting with '/' and containing also query parameters\n   * @param body - request body, will be utf-8 encoded\n   * @returns a configuration object that is suitable for making the request\n   */\n  private _createRequestMessage(\n    path: string,\n    body: string,\n    sendOptions: SendOptions,\n    resolve: (req: http.RequestOptions) => void,\n    reject: (err: Error) => void\n  ): void {\n    const bodyBuffer = Buffer.from(body, 'utf-8')\n    const headers: {[key: string]: any} = {\n      'content-type': 'application/json; charset=utf-8',\n      ...this._headers,\n    }\n    if (this._token) {\n      headers.authorization = `Token ${this._token}`\n    }\n    const options: {[key: string]: any} = {\n      ...this._defaultOptions,\n      path: this._contextPath + path,\n      method: sendOptions.method,\n      headers: {\n        ...headers,\n        ...sendOptions.headers,\n      },\n    }\n    if (sendOptions.signal) {\n      options.signal = sendOptions.signal\n    }\n    if (\n      sendOptions.gzipThreshold !== undefined &&\n      sendOptions.gzipThreshold < bodyBuffer.length\n    ) {\n      zlib.gzip(bodyBuffer, (err, res) => {\n        /* istanbul ignore next - hard to simulate failure, manually reviewed */\n        if (err) {\n          return reject(err)\n        }\n        options.headers['content-encoding'] = 'gzip'\n        options.body = res\n        resolve(options)\n      })\n      return\n    }\n    options.body = bodyBuffer\n    options.headers['content-length'] = options.body.length\n    resolve(options)\n  }\n\n  private _prepareResponse(\n    res: http.IncomingMessage,\n    resolve: (res: Readable) => void,\n    reject: (err: Error) => void\n  ) {\n    res.on('aborted', () => {\n      reject(new AbortError())\n    })\n    res.on('error', reject)\n    /* istanbul ignore next statusCode is optional in http.IncomingMessage */\n    const statusCode = res.statusCode ?? 600\n    const contentEncoding = res.headers['content-encoding']\n    let responseData\n    if (contentEncoding === 'gzip') {\n      responseData = zlib.createGunzip(zlibOptions)\n      responseData = pipeline(res, responseData, (e) => e && reject(e))\n    } else {\n      responseData = res\n    }\n    if (statusCode >= 300) {\n      let body = ''\n      const isJson = String(res.headers['content-type']).startsWith(\n        'application/json'\n      )\n      responseData.on('data', (s) => {\n        body += s.toString()\n        if (!isJson && body.length > 1000) {\n          body = body.slice(0, 1000)\n          res.resume()\n        }\n      })\n      responseData.on('end', () => {\n        if (body === '' && !!res.headers['x-influxdb-error']) {\n          body = res.headers['x-influxdb-error'].toString()\n        }\n        reject(\n          new HttpError(\n            statusCode,\n            res.statusMessage,\n            body,\n            res.headers['retry-after'],\n            res.headers['content-type']\n          )\n        )\n      })\n    } else {\n      resolve(responseData)\n    }\n  }\n\n  private _request(\n    requestMessage: {[key: string]: any},\n    cancellable: CancellableImpl,\n    callbacks?: Partial<CommunicationObserver<any>>\n  ): void {\n    const listeners = completeCommunicationObserver(callbacks)\n    if (cancellable.isCancelled()) {\n      listeners.complete()\n      return\n    }\n    if (requestMessage.signal?.addEventListener) {\n      ;(requestMessage.signal as AbortSignal).addEventListener('abort', () => {\n        listeners.error(new AbortError())\n      })\n    }\n    const req = this._requestApi(\n      requestMessage,\n      (res: http.IncomingMessage) => {\n        /* istanbul ignore next - hard to simulate failure, manually reviewed */\n        if (cancellable.isCancelled()) {\n          res.resume()\n          listeners.complete()\n          return\n        }\n        listeners.responseStarted(res.headers, res.statusCode)\n        this._prepareResponse(\n          res,\n          (responseData) => {\n            responseData.on('data', (data) => {\n              if (cancellable.isCancelled()) {\n                res.resume()\n              } else {\n                if (listeners.next(data) === false) {\n                  // pause processing, the consumer signalizes that\n                  // it is not able to receive more data\n                  if (!listeners.useResume) {\n                    listeners.error(\n                      new Error('Unable to pause, useResume is not configured!')\n                    )\n                    res.resume()\n                    return\n                  }\n                  res.pause()\n                  const resume = () => {\n                    res.resume()\n                  }\n                  cancellable.resume = resume\n                  listeners.useResume(resume)\n                }\n              }\n            })\n            responseData.on('end', listeners.complete)\n          },\n          listeners.error\n        )\n      }\n    )\n    // Support older Nodes which don't allow `timeout` in the\n    // request options\n    /* istanbul ignore else support older node versions */\n    if (typeof req.setTimeout === 'function' && requestMessage.timeout) {\n      req.setTimeout(requestMessage.timeout)\n    }\n\n    req.on('timeout', () => {\n      listeners.error(new RequestTimedOutError())\n    })\n    req.on('error', (error) => {\n      listeners.error(error)\n    })\n\n    /* istanbul ignore else support older node versions */\n    if (requestMessage.body) {\n      req.write(requestMessage.body)\n    }\n    req.end()\n  }\n}\nexport default NodeHttpTransport\n","import {CommunicationObserver, Headers} from '../results'\n\ntype CompleteObserver = Omit<\n  Required<CommunicationObserver<any>>,\n  'useCancellable' | 'useResume'\n> &\n  Pick<CommunicationObserver<any>, 'useResume' | 'useCancellable'>\n\nexport default function completeCommunicationObserver(\n  callbacks: Partial<CommunicationObserver<any>> = {}\n): CompleteObserver {\n  let state = 0\n  const retVal: CompleteObserver = {\n    next: (data: any): void | boolean => {\n      if (\n        state === 0 &&\n        callbacks.next &&\n        data !== null &&\n        data !== undefined\n      ) {\n        return callbacks.next(data)\n      }\n    },\n    error: (error: Error): void => {\n      /* istanbul ignore else propagate error at most once */\n      if (state === 0) {\n        state = 1\n        /* istanbul ignore else safety check */\n        if (callbacks.error) callbacks.error(error)\n      }\n    },\n    complete: (): void => {\n      if (state === 0) {\n        state = 2\n        /* istanbul ignore else safety check */\n        if (callbacks.complete) callbacks.complete()\n      }\n    },\n    responseStarted: (headers: Headers, statusCode?: number): void => {\n      if (callbacks.responseStarted)\n        callbacks.responseStarted(headers, statusCode)\n    },\n  }\n  if (callbacks.useCancellable) {\n    retVal.useCancellable = callbacks.useCancellable.bind(callbacks)\n  }\n  if (callbacks.useResume) {\n    retVal.useResume = callbacks.useResume.bind(callbacks)\n  }\n  return retVal\n}\n","export const CLIENT_LIB_VERSION = '0.3.1'\n","import {GrpcTransport} from '@protobuf-ts/grpc-transport'\nimport {replaceURLProtocolWithPort} from '../../util/fixUrl'\nimport {CreateQueryTransport} from '../implSelector'\nimport * as grpc from '@grpc/grpc-js'\n\nexport const createTransport: CreateQueryTransport = ({host}) => {\n  const {url, safe} = replaceURLProtocolWithPort(host)\n  const channelCredentials =\n    grpc.credentials[safe ?? true ? 'createSsl' : 'createInsecure']()\n\n  return new GrpcTransport({host: url, channelCredentials})\n}\n","const HTTP_PREFIX = 'http://'\nconst HTTPS_PREFIX = 'https://'\n\n/**\n * replaceURLProtocolWithPort removes the \"http://\" or \"https://\" protocol from the given URL and replaces it with the port number.\n * Currently, Apache Arrow does not support the \"http://\" or \"https://\" protocol in the URL, so this function is used to remove it.\n * If a port number is already present in the URL, only the protocol is removed.\n * The function also returns a boolean value indicating whether the communication is safe or unsafe.\n * - If the URL starts with \"https://\", the communication is considered safe, and the returned boolean value will be true.\n * - If the URL starts with \"http://\", the communication is considered unsafe, and the returned boolean value will be false.\n * - If the URL does not start with either \"http://\" or \"https://\", the returned boolean value will be undefined.\n *\n * @param url - The URL to process.\n * @returns An object containing the modified URL with the protocol replaced by the port and a boolean value indicating the safety of communication (true for safe, false for unsafe) or undefined if not detected.\n */\nexport const replaceURLProtocolWithPort = (\n  url: string\n): {url: string; safe: boolean | undefined} => {\n  url = url.replace(/\\/$/, '')\n\n  let safe: boolean | undefined\n\n  if (url.startsWith(HTTP_PREFIX)) {\n    url = url.slice(HTTP_PREFIX.length)\n    safe = false\n\n    if (!url.includes(':')) {\n      url = `${url}:80`\n    }\n  } else if (url.startsWith(HTTPS_PREFIX)) {\n    url = url.slice(HTTPS_PREFIX.length)\n    safe = true\n\n    if (!url.includes(':')) {\n      url = `${url}:443`\n    }\n  }\n\n  return {url, safe}\n}\n","import {TargetBasedImplementation} from '../implSelector'\nimport NodeHttpTransport from './NodeHttpTransport'\nimport {createTransport} from './rpc'\n\nconst implementation: TargetBasedImplementation = {\n  writeTransport: (opts) => new NodeHttpTransport(opts),\n  queryTransport: createTransport,\n}\n\nexport default implementation\n","import WriteApi from '../WriteApi'\nimport {ClientOptions, DEFAULT_WriteOptions, WriteOptions} from '../options'\nimport {Transport} from '../transport'\nimport {Headers} from '../results'\nimport {Log} from '../util/logger'\nimport {HttpError} from '../errors'\nimport {impl} from './implSelector'\n\nexport default class WriteApiImpl implements WriteApi {\n  private _closed = false\n  private _transport: Transport\n\n  constructor(private _options: ClientOptions) {\n    this._transport =\n      this._options.transport ?? impl.writeTransport(this._options)\n    this.doWrite = this.doWrite.bind(this)\n  }\n\n  private _createWritePath(\n    bucket: string,\n    writeOptions: WriteOptions,\n    org?: string\n  ) {\n    const query: string[] = [\n      `bucket=${encodeURIComponent(bucket)}`,\n      `precision=${writeOptions.precision}`,\n    ]\n    if (org) query.push(`org=${encodeURIComponent(org)}`)\n    const consistency = writeOptions?.consistency\n    if (consistency)\n      query.push(`consistency=${encodeURIComponent(consistency)}`)\n\n    const path = `/api/v2/write?${query.join('&')}`\n    return path\n  }\n\n  doWrite(\n    lines: string[],\n    bucket: string,\n    org?: string,\n    writeOptions?: Partial<WriteOptions>\n  ): Promise<void> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self: WriteApiImpl = this\n    if (self._closed) {\n      return Promise.reject(new Error('writeApi: already closed!'))\n    }\n    if (lines.length <= 0 || (lines.length === 1 && lines[0] === ''))\n      return Promise.resolve()\n\n    let resolve: (value: void | PromiseLike<void>) => void\n    let reject: (reason?: any) => void\n    const promise = new Promise<void>((res, rej) => {\n      resolve = res\n      reject = rej\n    })\n\n    let responseStatusCode: number | undefined\n    const callbacks = {\n      responseStarted(_headers: Headers, statusCode?: number): void {\n        responseStatusCode = statusCode\n      },\n      error(error: Error): void {\n        // ignore informational message about the state of InfluxDB\n        // enterprise cluster, if present\n        if (\n          error instanceof HttpError &&\n          error.json &&\n          typeof error.json.error === 'string' &&\n          error.json.error.includes('hinted handoff queue not empty')\n        ) {\n          Log.warn(`Write to InfluxDB returns: ${error.json.error}`)\n          responseStatusCode = 204\n          callbacks.complete()\n          return\n        }\n        Log.error(`Write to InfluxDB failed.`, error)\n        reject(error)\n      },\n      complete(): void {\n        // older implementations of transport do not report status code\n        if (responseStatusCode == 204 || responseStatusCode == undefined) {\n          resolve()\n        } else {\n          const message = `204 HTTP response status code expected, but ${responseStatusCode} returned`\n          const error = new HttpError(\n            responseStatusCode,\n            message,\n            undefined,\n            '0'\n          )\n          error.message = message\n          callbacks.error(error)\n        }\n      },\n    }\n\n    const writeOptionsOrDefault: WriteOptions = {\n      ...DEFAULT_WriteOptions,\n      ...writeOptions,\n    }\n    const sendOptions = {\n      method: 'POST',\n      headers: {\n        'content-type': 'text/plain; charset=utf-8',\n        ...writeOptions?.headers,\n      },\n      gzipThreshold: writeOptionsOrDefault.gzipThreshold,\n    }\n\n    this._transport.send(\n      this._createWritePath(bucket, writeOptionsOrDefault, org),\n      lines.join('\\n'),\n      sendOptions,\n      callbacks\n    )\n\n    return promise\n  }\n\n  async close(): Promise<void> {\n    this._closed = true\n  }\n}\n","import {RecordBatchReader, Type as ArrowType} from 'apache-arrow'\nimport QueryApi from '../QueryApi'\nimport {Ticket} from '../generated/flight/Flight'\nimport {FlightServiceClient} from '../generated/flight/Flight.client'\nimport {ConnectionOptions, QueryType} from '../options'\nimport {createInt32Uint8Array} from '../util/common'\nimport {RpcMetadata, RpcOptions} from '@protobuf-ts/runtime-rpc'\nimport {impl} from './implSelector'\nimport {PointFieldType, PointValues} from '../PointValues'\n\nexport default class QueryApiImpl implements QueryApi {\n  private _closed = false\n  private _flightClient: FlightServiceClient\n  private _transport: ReturnType<typeof impl.queryTransport>\n\n  constructor(private _options: ConnectionOptions) {\n    this._transport = impl.queryTransport(this._options)\n    this._flightClient = new FlightServiceClient(this._transport)\n  }\n\n  private async *_queryRawBatches(\n    query: string,\n    database: string,\n    queryType: QueryType\n  ) {\n    if (this._closed) {\n      throw new Error('queryApi: already closed!')\n    }\n    const client = this._flightClient\n\n    const ticketData = {\n      database: database,\n      sql_query: query,\n      query_type: queryType,\n    }\n    const ticket = Ticket.create({\n      ticket: new TextEncoder().encode(JSON.stringify(ticketData)),\n    })\n\n    const meta: RpcMetadata = {}\n\n    const token = this._options.token\n    if (token) meta['authorization'] = `Bearer ${token}`\n\n    const options: RpcOptions = {meta}\n\n    const flightDataStream = client.doGet(ticket, options)\n\n    const binaryStream = (async function* () {\n      for await (const flightData of flightDataStream.responses) {\n        // Include the length of dataHeader for the reader.\n        yield createInt32Uint8Array(flightData.dataHeader.length)\n        yield flightData.dataHeader\n        // Length of dataBody is already included in dataHeader.\n        yield flightData.dataBody\n      }\n    })()\n\n    const reader = await RecordBatchReader.from(binaryStream)\n\n    yield* reader\n  }\n\n  async *query(\n    query: string,\n    database: string,\n    queryType: QueryType\n  ): AsyncGenerator<Record<string, any>, void, void> {\n    const batches = this._queryRawBatches(query, database, queryType)\n\n    for await (const batch of batches) {\n      for (let rowIndex = 0; rowIndex < batch.numRows; rowIndex++) {\n        const row: Record<string, any> = {}\n        for (let columnIndex = 0; columnIndex < batch.numCols; columnIndex++) {\n          const name = batch.schema.fields[columnIndex].name\n          const value = batch.getChildAt(columnIndex)?.get(rowIndex)\n          row[name] = value\n        }\n\n        yield row\n      }\n    }\n  }\n\n  async *queryPoints(\n    query: string,\n    database: string,\n    queryType: QueryType\n  ): AsyncGenerator<PointValues, void, void> {\n    const batches = this._queryRawBatches(query, database, queryType)\n\n    for await (const batch of batches) {\n      for (let rowIndex = 0; rowIndex < batch.numRows; rowIndex++) {\n        const values = new PointValues()\n        for (let columnIndex = 0; columnIndex < batch.numCols; columnIndex++) {\n          const columnSchema = batch.schema.fields[columnIndex]\n          const name = columnSchema.name\n          const value = batch.getChildAt(columnIndex)?.get(rowIndex)\n          const arrowTypeId = columnSchema.typeId\n          const metaType = columnSchema.metadata.get('iox::column::type')\n\n          if (value === undefined || value === null) continue\n\n          if (\n            (name === 'measurement' || name == 'iox::measurement') &&\n            typeof value === 'string'\n          ) {\n            values.setMeasurement(value)\n            continue\n          }\n\n          if (!metaType) {\n            if (name === 'time' && arrowTypeId === ArrowType.Timestamp) {\n              values.setTimestamp(value)\n            } else {\n              values.setField(name, value)\n            }\n\n            continue\n          }\n\n          const [, , valueType, _fieldType] = metaType.split('::')\n\n          if (valueType === 'field') {\n            if (_fieldType && value !== undefined && value !== null)\n              values.setField(name, value, _fieldType as PointFieldType)\n          } else if (valueType === 'tag') {\n            values.setTag(name, value)\n          } else if (valueType === 'timestamp') {\n            values.setTimestamp(value)\n          }\n        }\n\n        yield values\n      }\n    }\n  }\n\n  async close(): Promise<void> {\n    this._closed = true\n    this._transport.close?.()\n  }\n}\n","// @generated by protobuf-ts 2.9.0 with parameter optimize_code_size\n// @generated from protobuf file \"Flight.proto\" (package \"arrow.flight.protocol\", syntax proto3)\n// tslint:disable\n//\n//\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n// <p>\n// http://www.apache.org/licenses/LICENSE-2.0\n// <p>\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\nimport { ServiceType } from \"@protobuf-ts/runtime-rpc\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\nimport { Timestamp } from \"./google/protobuf/timestamp\";\n/**\n *\n * The request that a client provides to a server on handshake.\n *\n * @generated from protobuf message arrow.flight.protocol.HandshakeRequest\n */\nexport interface HandshakeRequest {\n    /**\n     *\n     * A defined protocol version\n     *\n     * @generated from protobuf field: uint64 protocol_version = 1;\n     */\n    protocolVersion: bigint;\n    /**\n     *\n     * Arbitrary auth/handshake info.\n     *\n     * @generated from protobuf field: bytes payload = 2;\n     */\n    payload: Uint8Array;\n}\n/**\n * @generated from protobuf message arrow.flight.protocol.HandshakeResponse\n */\nexport interface HandshakeResponse {\n    /**\n     *\n     * A defined protocol version\n     *\n     * @generated from protobuf field: uint64 protocol_version = 1;\n     */\n    protocolVersion: bigint;\n    /**\n     *\n     * Arbitrary auth/handshake info.\n     *\n     * @generated from protobuf field: bytes payload = 2;\n     */\n    payload: Uint8Array;\n}\n/**\n *\n * A message for doing simple auth.\n *\n * @generated from protobuf message arrow.flight.protocol.BasicAuth\n */\nexport interface BasicAuth {\n    /**\n     * @generated from protobuf field: string username = 2;\n     */\n    username: string;\n    /**\n     * @generated from protobuf field: string password = 3;\n     */\n    password: string;\n}\n/**\n * @generated from protobuf message arrow.flight.protocol.Empty\n */\nexport interface Empty {\n}\n/**\n *\n * Describes an available action, including both the name used for execution\n * along with a short description of the purpose of the action.\n *\n * @generated from protobuf message arrow.flight.protocol.ActionType\n */\nexport interface ActionType {\n    /**\n     * @generated from protobuf field: string type = 1;\n     */\n    type: string;\n    /**\n     * @generated from protobuf field: string description = 2;\n     */\n    description: string;\n}\n/**\n *\n * A service specific expression that can be used to return a limited set\n * of available Arrow Flight streams.\n *\n * @generated from protobuf message arrow.flight.protocol.Criteria\n */\nexport interface Criteria {\n    /**\n     * @generated from protobuf field: bytes expression = 1;\n     */\n    expression: Uint8Array;\n}\n/**\n *\n * An opaque action specific for the service.\n *\n * @generated from protobuf message arrow.flight.protocol.Action\n */\nexport interface Action {\n    /**\n     * @generated from protobuf field: string type = 1;\n     */\n    type: string;\n    /**\n     * @generated from protobuf field: bytes body = 2;\n     */\n    body: Uint8Array;\n}\n/**\n *\n * The request of the CancelFlightInfo action.\n *\n * The request should be stored in Action.body.\n *\n * @generated from protobuf message arrow.flight.protocol.CancelFlightInfoRequest\n */\nexport interface CancelFlightInfoRequest {\n    /**\n     * @generated from protobuf field: arrow.flight.protocol.FlightInfo info = 1;\n     */\n    info?: FlightInfo;\n}\n/**\n *\n * The request of the RenewFlightEndpoint action.\n *\n * The request should be stored in Action.body.\n *\n * @generated from protobuf message arrow.flight.protocol.RenewFlightEndpointRequest\n */\nexport interface RenewFlightEndpointRequest {\n    /**\n     * @generated from protobuf field: arrow.flight.protocol.FlightEndpoint endpoint = 1;\n     */\n    endpoint?: FlightEndpoint;\n}\n/**\n *\n * An opaque result returned after executing an action.\n *\n * @generated from protobuf message arrow.flight.protocol.Result\n */\nexport interface Result {\n    /**\n     * @generated from protobuf field: bytes body = 1;\n     */\n    body: Uint8Array;\n}\n/**\n *\n * The result of the CancelFlightInfo action.\n *\n * The result should be stored in Result.body.\n *\n * @generated from protobuf message arrow.flight.protocol.CancelFlightInfoResult\n */\nexport interface CancelFlightInfoResult {\n    /**\n     * @generated from protobuf field: arrow.flight.protocol.CancelStatus status = 1;\n     */\n    status: CancelStatus;\n}\n/**\n *\n * Wrap the result of a getSchema call\n *\n * @generated from protobuf message arrow.flight.protocol.SchemaResult\n */\nexport interface SchemaResult {\n    /**\n     * The schema of the dataset in its IPC form:\n     *   4 bytes - an optional IPC_CONTINUATION_TOKEN prefix\n     *   4 bytes - the byte length of the payload\n     *   a flatbuffer Message whose header is the Schema\n     *\n     * @generated from protobuf field: bytes schema = 1;\n     */\n    schema: Uint8Array;\n}\n/**\n *\n * The name or tag for a Flight. May be used as a way to retrieve or generate\n * a flight or be used to expose a set of previously defined flights.\n *\n * @generated from protobuf message arrow.flight.protocol.FlightDescriptor\n */\nexport interface FlightDescriptor {\n    /**\n     * @generated from protobuf field: arrow.flight.protocol.FlightDescriptor.DescriptorType type = 1;\n     */\n    type: FlightDescriptor_DescriptorType;\n    /**\n     *\n     * Opaque value used to express a command. Should only be defined when\n     * type = CMD.\n     *\n     * @generated from protobuf field: bytes cmd = 2;\n     */\n    cmd: Uint8Array;\n    /**\n     *\n     * List of strings identifying a particular dataset. Should only be defined\n     * when type = PATH.\n     *\n     * @generated from protobuf field: repeated string path = 3;\n     */\n    path: string[];\n}\n/**\n *\n * Describes what type of descriptor is defined.\n *\n * @generated from protobuf enum arrow.flight.protocol.FlightDescriptor.DescriptorType\n */\nexport enum FlightDescriptor_DescriptorType {\n    /**\n     * Protobuf pattern, not used.\n     *\n     * @generated from protobuf enum value: UNKNOWN = 0;\n     */\n    UNKNOWN = 0,\n    /**\n     *\n     * A named path that identifies a dataset. A path is composed of a string\n     * or list of strings describing a particular dataset. This is conceptually\n     *  similar to a path inside a filesystem.\n     *\n     * @generated from protobuf enum value: PATH = 1;\n     */\n    PATH = 1,\n    /**\n     *\n     * An opaque command to generate a dataset.\n     *\n     * @generated from protobuf enum value: CMD = 2;\n     */\n    CMD = 2\n}\n/**\n *\n * The access coordinates for retrieval of a dataset. With a FlightInfo, a\n * consumer is able to determine how to retrieve a dataset.\n *\n * @generated from protobuf message arrow.flight.protocol.FlightInfo\n */\nexport interface FlightInfo {\n    /**\n     * The schema of the dataset in its IPC form:\n     *   4 bytes - an optional IPC_CONTINUATION_TOKEN prefix\n     *   4 bytes - the byte length of the payload\n     *   a flatbuffer Message whose header is the Schema\n     *\n     * @generated from protobuf field: bytes schema = 1;\n     */\n    schema: Uint8Array;\n    /**\n     *\n     * The descriptor associated with this info.\n     *\n     * @generated from protobuf field: arrow.flight.protocol.FlightDescriptor flight_descriptor = 2;\n     */\n    flightDescriptor?: FlightDescriptor;\n    /**\n     *\n     * A list of endpoints associated with the flight. To consume the\n     * whole flight, all endpoints (and hence all Tickets) must be\n     * consumed. Endpoints can be consumed in any order.\n     *\n     * In other words, an application can use multiple endpoints to\n     * represent partitioned data.\n     *\n     * If the returned data has an ordering, an application can use\n     * \"FlightInfo.ordered = true\" or should return the all data in a\n     * single endpoint. Otherwise, there is no ordering defined on\n     * endpoints or the data within.\n     *\n     * A client can read ordered data by reading data from returned\n     * endpoints, in order, from front to back.\n     *\n     * Note that a client may ignore \"FlightInfo.ordered = true\". If an\n     * ordering is important for an application, an application must\n     * choose one of them:\n     *\n     * * An application requires that all clients must read data in\n     *   returned endpoints order.\n     * * An application must return the all data in a single endpoint.\n     *\n     * @generated from protobuf field: repeated arrow.flight.protocol.FlightEndpoint endpoint = 3;\n     */\n    endpoint: FlightEndpoint[];\n    /**\n     * Set these to -1 if unknown.\n     *\n     * @generated from protobuf field: int64 total_records = 4;\n     */\n    totalRecords: bigint;\n    /**\n     * @generated from protobuf field: int64 total_bytes = 5;\n     */\n    totalBytes: bigint;\n    /**\n     *\n     * FlightEndpoints are in the same order as the data.\n     *\n     * @generated from protobuf field: bool ordered = 6;\n     */\n    ordered: boolean;\n}\n/**\n *\n * A particular stream or split associated with a flight.\n *\n * @generated from protobuf message arrow.flight.protocol.FlightEndpoint\n */\nexport interface FlightEndpoint {\n    /**\n     *\n     * Token used to retrieve this stream.\n     *\n     * @generated from protobuf field: arrow.flight.protocol.Ticket ticket = 1;\n     */\n    ticket?: Ticket;\n    /**\n     *\n     * A list of URIs where this ticket can be redeemed via DoGet().\n     *\n     * If the list is empty, the expectation is that the ticket can only\n     * be redeemed on the current service where the ticket was\n     * generated.\n     *\n     * If the list is not empty, the expectation is that the ticket can\n     * be redeemed at any of the locations, and that the data returned\n     * will be equivalent. In this case, the ticket may only be redeemed\n     * at one of the given locations, and not (necessarily) on the\n     * current service.\n     *\n     * In other words, an application can use multiple locations to\n     * represent redundant and/or load balanced services.\n     *\n     * @generated from protobuf field: repeated arrow.flight.protocol.Location location = 2;\n     */\n    location: Location[];\n    /**\n     *\n     * Expiration time of this stream. If present, clients may assume\n     * they can retry DoGet requests. Otherwise, it is\n     * application-defined whether DoGet requests may be retried.\n     *\n     * @generated from protobuf field: google.protobuf.Timestamp expiration_time = 3;\n     */\n    expirationTime?: Timestamp;\n}\n/**\n *\n * A location where a Flight service will accept retrieval of a particular\n * stream given a ticket.\n *\n * @generated from protobuf message arrow.flight.protocol.Location\n */\nexport interface Location {\n    /**\n     * @generated from protobuf field: string uri = 1;\n     */\n    uri: string;\n}\n/**\n *\n * An opaque identifier that the service can use to retrieve a particular\n * portion of a stream.\n *\n * Tickets are meant to be single use. It is an error/application-defined\n * behavior to reuse a ticket.\n *\n * @generated from protobuf message arrow.flight.protocol.Ticket\n */\nexport interface Ticket {\n    /**\n     * @generated from protobuf field: bytes ticket = 1;\n     */\n    ticket: Uint8Array;\n}\n/**\n *\n * A batch of Arrow data as part of a stream of batches.\n *\n * @generated from protobuf message arrow.flight.protocol.FlightData\n */\nexport interface FlightData {\n    /**\n     *\n     * The descriptor of the data. This is only relevant when a client is\n     * starting a new DoPut stream.\n     *\n     * @generated from protobuf field: arrow.flight.protocol.FlightDescriptor flight_descriptor = 1;\n     */\n    flightDescriptor?: FlightDescriptor;\n    /**\n     *\n     * Header for message data as described in Message.fbs::Message.\n     *\n     * @generated from protobuf field: bytes data_header = 2;\n     */\n    dataHeader: Uint8Array;\n    /**\n     *\n     * Application-defined metadata.\n     *\n     * @generated from protobuf field: bytes app_metadata = 3;\n     */\n    appMetadata: Uint8Array;\n    /**\n     *\n     * The actual batch of Arrow data. Preferably handled with minimal-copies\n     * coming last in the definition to help with sidecar patterns (it is\n     * expected that some implementations will fetch this field off the wire\n     * with specialized code to avoid extra memory copies).\n     *\n     * @generated from protobuf field: bytes data_body = 1000;\n     */\n    dataBody: Uint8Array;\n}\n/**\n * *\n * The response message associated with the submission of a DoPut.\n *\n * @generated from protobuf message arrow.flight.protocol.PutResult\n */\nexport interface PutResult {\n    /**\n     * @generated from protobuf field: bytes app_metadata = 1;\n     */\n    appMetadata: Uint8Array;\n}\n/**\n *\n * The result of a cancel operation.\n *\n * This is used by CancelFlightInfoResult.status.\n *\n * @generated from protobuf enum arrow.flight.protocol.CancelStatus\n */\nexport enum CancelStatus {\n    /**\n     * The cancellation status is unknown. Servers should avoid using\n     * this value (send a NOT_FOUND error if the requested query is\n     * not known). Clients can retry the request.\n     *\n     * @generated from protobuf enum value: CANCEL_STATUS_UNSPECIFIED = 0;\n     */\n    UNSPECIFIED = 0,\n    /**\n     * The cancellation request is complete. Subsequent requests with\n     * the same payload may return CANCELLED or a NOT_FOUND error.\n     *\n     * @generated from protobuf enum value: CANCEL_STATUS_CANCELLED = 1;\n     */\n    CANCELLED = 1,\n    /**\n     * The cancellation request is in progress. The client may retry\n     * the cancellation request.\n     *\n     * @generated from protobuf enum value: CANCEL_STATUS_CANCELLING = 2;\n     */\n    CANCELLING = 2,\n    /**\n     * The query is not cancellable. The client should not retry the\n     * cancellation request.\n     *\n     * @generated from protobuf enum value: CANCEL_STATUS_NOT_CANCELLABLE = 3;\n     */\n    NOT_CANCELLABLE = 3\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass HandshakeRequest$Type extends MessageType<HandshakeRequest> {\n    constructor() {\n        super(\"arrow.flight.protocol.HandshakeRequest\", [\n            { no: 1, name: \"protocol_version\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"payload\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.HandshakeRequest\n */\nexport const HandshakeRequest = new HandshakeRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass HandshakeResponse$Type extends MessageType<HandshakeResponse> {\n    constructor() {\n        super(\"arrow.flight.protocol.HandshakeResponse\", [\n            { no: 1, name: \"protocol_version\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"payload\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.HandshakeResponse\n */\nexport const HandshakeResponse = new HandshakeResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass BasicAuth$Type extends MessageType<BasicAuth> {\n    constructor() {\n        super(\"arrow.flight.protocol.BasicAuth\", [\n            { no: 2, name: \"username\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"password\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.BasicAuth\n */\nexport const BasicAuth = new BasicAuth$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Empty$Type extends MessageType<Empty> {\n    constructor() {\n        super(\"arrow.flight.protocol.Empty\", []);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.Empty\n */\nexport const Empty = new Empty$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ActionType$Type extends MessageType<ActionType> {\n    constructor() {\n        super(\"arrow.flight.protocol.ActionType\", [\n            { no: 1, name: \"type\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"description\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.ActionType\n */\nexport const ActionType = new ActionType$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Criteria$Type extends MessageType<Criteria> {\n    constructor() {\n        super(\"arrow.flight.protocol.Criteria\", [\n            { no: 1, name: \"expression\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.Criteria\n */\nexport const Criteria = new Criteria$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Action$Type extends MessageType<Action> {\n    constructor() {\n        super(\"arrow.flight.protocol.Action\", [\n            { no: 1, name: \"type\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"body\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.Action\n */\nexport const Action = new Action$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CancelFlightInfoRequest$Type extends MessageType<CancelFlightInfoRequest> {\n    constructor() {\n        super(\"arrow.flight.protocol.CancelFlightInfoRequest\", [\n            { no: 1, name: \"info\", kind: \"message\", T: () => FlightInfo }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.CancelFlightInfoRequest\n */\nexport const CancelFlightInfoRequest = new CancelFlightInfoRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass RenewFlightEndpointRequest$Type extends MessageType<RenewFlightEndpointRequest> {\n    constructor() {\n        super(\"arrow.flight.protocol.RenewFlightEndpointRequest\", [\n            { no: 1, name: \"endpoint\", kind: \"message\", T: () => FlightEndpoint }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.RenewFlightEndpointRequest\n */\nexport const RenewFlightEndpointRequest = new RenewFlightEndpointRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Result$Type extends MessageType<Result> {\n    constructor() {\n        super(\"arrow.flight.protocol.Result\", [\n            { no: 1, name: \"body\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.Result\n */\nexport const Result = new Result$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CancelFlightInfoResult$Type extends MessageType<CancelFlightInfoResult> {\n    constructor() {\n        super(\"arrow.flight.protocol.CancelFlightInfoResult\", [\n            { no: 1, name: \"status\", kind: \"enum\", T: () => [\"arrow.flight.protocol.CancelStatus\", CancelStatus, \"CANCEL_STATUS_\"] }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.CancelFlightInfoResult\n */\nexport const CancelFlightInfoResult = new CancelFlightInfoResult$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SchemaResult$Type extends MessageType<SchemaResult> {\n    constructor() {\n        super(\"arrow.flight.protocol.SchemaResult\", [\n            { no: 1, name: \"schema\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.SchemaResult\n */\nexport const SchemaResult = new SchemaResult$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass FlightDescriptor$Type extends MessageType<FlightDescriptor> {\n    constructor() {\n        super(\"arrow.flight.protocol.FlightDescriptor\", [\n            { no: 1, name: \"type\", kind: \"enum\", T: () => [\"arrow.flight.protocol.FlightDescriptor.DescriptorType\", FlightDescriptor_DescriptorType] },\n            { no: 2, name: \"cmd\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"path\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.FlightDescriptor\n */\nexport const FlightDescriptor = new FlightDescriptor$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass FlightInfo$Type extends MessageType<FlightInfo> {\n    constructor() {\n        super(\"arrow.flight.protocol.FlightInfo\", [\n            { no: 1, name: \"schema\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"flight_descriptor\", kind: \"message\", T: () => FlightDescriptor },\n            { no: 3, name: \"endpoint\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => FlightEndpoint },\n            { no: 4, name: \"total_records\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 5, name: \"total_bytes\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 6, name: \"ordered\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.FlightInfo\n */\nexport const FlightInfo = new FlightInfo$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass FlightEndpoint$Type extends MessageType<FlightEndpoint> {\n    constructor() {\n        super(\"arrow.flight.protocol.FlightEndpoint\", [\n            { no: 1, name: \"ticket\", kind: \"message\", T: () => Ticket },\n            { no: 2, name: \"location\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => Location },\n            { no: 3, name: \"expiration_time\", kind: \"message\", T: () => Timestamp }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.FlightEndpoint\n */\nexport const FlightEndpoint = new FlightEndpoint$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Location$Type extends MessageType<Location> {\n    constructor() {\n        super(\"arrow.flight.protocol.Location\", [\n            { no: 1, name: \"uri\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.Location\n */\nexport const Location = new Location$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Ticket$Type extends MessageType<Ticket> {\n    constructor() {\n        super(\"arrow.flight.protocol.Ticket\", [\n            { no: 1, name: \"ticket\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.Ticket\n */\nexport const Ticket = new Ticket$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass FlightData$Type extends MessageType<FlightData> {\n    constructor() {\n        super(\"arrow.flight.protocol.FlightData\", [\n            { no: 1, name: \"flight_descriptor\", kind: \"message\", T: () => FlightDescriptor },\n            { no: 2, name: \"data_header\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"app_metadata\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 1000, name: \"data_body\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.FlightData\n */\nexport const FlightData = new FlightData$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PutResult$Type extends MessageType<PutResult> {\n    constructor() {\n        super(\"arrow.flight.protocol.PutResult\", [\n            { no: 1, name: \"app_metadata\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n}\n/**\n * @generated MessageType for protobuf message arrow.flight.protocol.PutResult\n */\nexport const PutResult = new PutResult$Type();\n/**\n * @generated ServiceType for protobuf service arrow.flight.protocol.FlightService\n */\nexport const FlightService = new ServiceType(\"arrow.flight.protocol.FlightService\", [\n    { name: \"Handshake\", serverStreaming: true, clientStreaming: true, options: {}, I: HandshakeRequest, O: HandshakeResponse },\n    { name: \"ListFlights\", serverStreaming: true, options: {}, I: Criteria, O: FlightInfo },\n    { name: \"GetFlightInfo\", options: {}, I: FlightDescriptor, O: FlightInfo },\n    { name: \"GetSchema\", options: {}, I: FlightDescriptor, O: SchemaResult },\n    { name: \"DoGet\", serverStreaming: true, options: {}, I: Ticket, O: FlightData },\n    { name: \"DoPut\", serverStreaming: true, clientStreaming: true, options: {}, I: FlightData, O: PutResult },\n    { name: \"DoExchange\", serverStreaming: true, clientStreaming: true, options: {}, I: FlightData, O: FlightData },\n    { name: \"DoAction\", serverStreaming: true, options: {}, I: Action, O: Result },\n    { name: \"ListActions\", serverStreaming: true, options: {}, I: Empty, O: ActionType }\n]);\n","/**\n * Get the type of a JSON value.\n * Distinguishes between array, null and object.\n */\nexport function typeofJsonValue(value) {\n    let t = typeof value;\n    if (t == \"object\") {\n        if (Array.isArray(value))\n            return \"array\";\n        if (value === null)\n            return \"null\";\n    }\n    return t;\n}\n/**\n * Is this a JSON object (instead of an array or null)?\n */\nexport function isJsonObject(value) {\n    return value !== null && typeof value == \"object\" && !Array.isArray(value);\n}\n","// lookup table from base64 character to byte\nlet encTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n// lookup table from base64 character *code* to byte because lookup by number is fast\nlet decTable = [];\nfor (let i = 0; i < encTable.length; i++)\n    decTable[encTable[i].charCodeAt(0)] = i;\n// support base64url variants\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\n/**\n * Decodes a base64 string to a byte array.\n *\n * - ignores white-space, including line breaks and tabs\n * - allows inner padding (can decode concatenated base64 strings)\n * - does not require padding\n * - understands base64url encoding:\n *   \"-\" instead of \"+\",\n *   \"_\" instead of \"/\",\n *   no padding\n */\nexport function base64decode(base64Str) {\n    // estimate byte size, not accounting for inner padding and whitespace\n    let es = base64Str.length * 3 / 4;\n    // if (es % 3 !== 0)\n    // throw new Error('invalid base64 string');\n    if (base64Str[base64Str.length - 2] == '=')\n        es -= 2;\n    else if (base64Str[base64Str.length - 1] == '=')\n        es -= 1;\n    let bytes = new Uint8Array(es), bytePos = 0, // position in byte array\n    groupPos = 0, // position in base64 group\n    b, // current byte\n    p = 0 // previous byte\n    ;\n    for (let i = 0; i < base64Str.length; i++) {\n        b = decTable[base64Str.charCodeAt(i)];\n        if (b === undefined) {\n            // noinspection FallThroughInSwitchStatementJS\n            switch (base64Str[i]) {\n                case '=':\n                    groupPos = 0; // reset state when padding found\n                case '\\n':\n                case '\\r':\n                case '\\t':\n                case ' ':\n                    continue; // skip white-space, and padding\n                default:\n                    throw Error(`invalid base64 string.`);\n            }\n        }\n        switch (groupPos) {\n            case 0:\n                p = b;\n                groupPos = 1;\n                break;\n            case 1:\n                bytes[bytePos++] = p << 2 | (b & 48) >> 4;\n                p = b;\n                groupPos = 2;\n                break;\n            case 2:\n                bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\n                p = b;\n                groupPos = 3;\n                break;\n            case 3:\n                bytes[bytePos++] = (p & 3) << 6 | b;\n                groupPos = 0;\n                break;\n        }\n    }\n    if (groupPos == 1)\n        throw Error(`invalid base64 string.`);\n    return bytes.subarray(0, bytePos);\n}\n/**\n * Encodes a byte array to a base64 string.\n * Adds padding at the end.\n * Does not insert newlines.\n */\nexport function base64encode(bytes) {\n    let base64 = '', groupPos = 0, // position in base64 group\n    b, // current byte\n    p = 0; // carry over from previous byte\n    for (let i = 0; i < bytes.length; i++) {\n        b = bytes[i];\n        switch (groupPos) {\n            case 0:\n                base64 += encTable[b >> 2];\n                p = (b & 3) << 4;\n                groupPos = 1;\n                break;\n            case 1:\n                base64 += encTable[p | b >> 4];\n                p = (b & 15) << 2;\n                groupPos = 2;\n                break;\n            case 2:\n                base64 += encTable[p | b >> 6];\n                base64 += encTable[b & 63];\n                groupPos = 0;\n                break;\n        }\n    }\n    // padding required?\n    if (groupPos) {\n        base64 += encTable[p];\n        base64 += '=';\n        if (groupPos == 1)\n            base64 += '=';\n    }\n    return base64;\n}\n","/**\n * This handler implements the default behaviour for unknown fields.\n * When reading data, unknown fields are stored on the message, in a\n * symbol property.\n * When writing data, the symbol property is queried and unknown fields\n * are serialized into the output again.\n */\nexport var UnknownFieldHandler;\n(function (UnknownFieldHandler) {\n    /**\n     * The symbol used to store unknown fields for a message.\n     * The property must conform to `UnknownFieldContainer`.\n     */\n    UnknownFieldHandler.symbol = Symbol.for(\"protobuf-ts/unknown\");\n    /**\n     * Store an unknown field during binary read directly on the message.\n     * This method is compatible with `BinaryReadOptions.readUnknownField`.\n     */\n    UnknownFieldHandler.onRead = (typeName, message, fieldNo, wireType, data) => {\n        let container = is(message) ? message[UnknownFieldHandler.symbol] : message[UnknownFieldHandler.symbol] = [];\n        container.push({ no: fieldNo, wireType, data });\n    };\n    /**\n     * Write unknown fields stored for the message to the writer.\n     * This method is compatible with `BinaryWriteOptions.writeUnknownFields`.\n     */\n    UnknownFieldHandler.onWrite = (typeName, message, writer) => {\n        for (let { no, wireType, data } of UnknownFieldHandler.list(message))\n            writer.tag(no, wireType).raw(data);\n    };\n    /**\n     * List unknown fields stored for the message.\n     * Note that there may be multiples fields with the same number.\n     */\n    UnknownFieldHandler.list = (message, fieldNo) => {\n        if (is(message)) {\n            let all = message[UnknownFieldHandler.symbol];\n            return fieldNo ? all.filter(uf => uf.no == fieldNo) : all;\n        }\n        return [];\n    };\n    /**\n     * Returns the last unknown field by field number.\n     */\n    UnknownFieldHandler.last = (message, fieldNo) => UnknownFieldHandler.list(message, fieldNo).slice(-1)[0];\n    const is = (message) => message && Array.isArray(message[UnknownFieldHandler.symbol]);\n})(UnknownFieldHandler || (UnknownFieldHandler = {}));\n/**\n * Merges binary write or read options. Later values override earlier values.\n */\nexport function mergeBinaryOptions(a, b) {\n    return Object.assign(Object.assign({}, a), b);\n}\n/**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */\nexport var WireType;\n(function (WireType) {\n    /**\n     * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n     */\n    WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n    /**\n     * Used for fixed64, sfixed64, double.\n     * Always 8 bytes with little-endian byte order.\n     */\n    WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\n    /**\n     * Used for string, bytes, embedded messages, packed repeated fields\n     *\n     * Only repeated numeric types (types which use the varint, 32-bit,\n     * or 64-bit wire types) can be packed. In proto3, such fields are\n     * packed by default.\n     */\n    WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\n    /**\n     * Used for groups\n     * @deprecated\n     */\n    WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\n    /**\n     * Used for groups\n     * @deprecated\n     */\n    WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\n    /**\n     * Used for fixed32, sfixed32, float.\n     * Always 4 bytes with little-endian byte order.\n     */\n    WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\n","// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [0]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */\nexport function varint64read() {\n    let lowBits = 0;\n    let highBits = 0;\n    for (let shift = 0; shift < 28; shift += 7) {\n        let b = this.buf[this.pos++];\n        lowBits |= (b & 0x7F) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [lowBits, highBits];\n        }\n    }\n    let middleByte = this.buf[this.pos++];\n    // last four bits of the first 32 bit number\n    lowBits |= (middleByte & 0x0F) << 28;\n    // 3 upper bits are part of the next 32 bit number\n    highBits = (middleByte & 0x70) >> 4;\n    if ((middleByte & 0x80) == 0) {\n        this.assertBounds();\n        return [lowBits, highBits];\n    }\n    for (let shift = 3; shift <= 31; shift += 7) {\n        let b = this.buf[this.pos++];\n        highBits |= (b & 0x7F) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [lowBits, highBits];\n        }\n    }\n    throw new Error('invalid varint');\n}\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */\nexport function varint64write(lo, hi, bytes) {\n    for (let i = 0; i < 28; i = i + 7) {\n        const shift = lo >>> i;\n        const hasNext = !((shift >>> 7) == 0 && hi == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    const splitBits = ((lo >>> 28) & 0x0F) | ((hi & 0x07) << 4);\n    const hasMoreBits = !((hi >> 3) == 0);\n    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xFF);\n    if (!hasMoreBits) {\n        return;\n    }\n    for (let i = 3; i < 31; i = i + 7) {\n        const shift = hi >>> i;\n        const hasNext = !((shift >>> 7) == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    bytes.push((hi >>> 31) & 0x01);\n}\n// constants for binary math\nconst TWO_PWR_32_DBL = (1 << 16) * (1 << 16);\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Returns tuple:\n * [0]: minus sign?\n * [1]: low bits\n * [2]: high bits\n *\n * Copyright 2008 Google Inc.\n */\nexport function int64fromString(dec) {\n    // Check for minus sign.\n    let minus = dec[0] == '-';\n    if (minus)\n        dec = dec.slice(1);\n    // Work 6 decimal digits at a time, acting like we're converting base 1e6\n    // digits to binary. This is safe to do with floating point math because\n    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n    const base = 1e6;\n    let lowBits = 0;\n    let highBits = 0;\n    function add1e6digit(begin, end) {\n        // Note: Number('') is 0.\n        const digit1e6 = Number(dec.slice(begin, end));\n        highBits *= base;\n        lowBits = lowBits * base + digit1e6;\n        // Carry bits from lowBits to highBits\n        if (lowBits >= TWO_PWR_32_DBL) {\n            highBits = highBits + ((lowBits / TWO_PWR_32_DBL) | 0);\n            lowBits = lowBits % TWO_PWR_32_DBL;\n        }\n    }\n    add1e6digit(-24, -18);\n    add1e6digit(-18, -12);\n    add1e6digit(-12, -6);\n    add1e6digit(-6);\n    return [minus, lowBits, highBits];\n}\n/**\n * Format 64 bit integer value (as two JS numbers) to decimal string.\n *\n * Copyright 2008 Google Inc.\n */\nexport function int64toString(bitsLow, bitsHigh) {\n    // Skip the expensive conversion if the number is small enough to use the\n    // built-in conversions.\n    if ((bitsHigh >>> 0) <= 0x1FFFFF) {\n        return '' + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));\n    }\n    // What this code is doing is essentially converting the input number from\n    // base-2 to base-1e7, which allows us to represent the 64-bit range with\n    // only 3 (very large) digits. Those digits are then trivial to convert to\n    // a base-10 string.\n    // The magic numbers used here are -\n    // 2^24 = 16777216 = (1,6777216) in base-1e7.\n    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n    // Split 32:32 representation into 16:24:24 representation so our\n    // intermediate digits don't overflow.\n    let low = bitsLow & 0xFFFFFF;\n    let mid = (((bitsLow >>> 24) | (bitsHigh << 8)) >>> 0) & 0xFFFFFF;\n    let high = (bitsHigh >> 16) & 0xFFFF;\n    // Assemble our three base-1e7 digits, ignoring carries. The maximum\n    // value in a digit at this step is representable as a 48-bit integer, which\n    // can be stored in a 64-bit floating point number.\n    let digitA = low + (mid * 6777216) + (high * 6710656);\n    let digitB = mid + (high * 8147497);\n    let digitC = (high * 2);\n    // Apply carries from A to B and from B to C.\n    let base = 10000000;\n    if (digitA >= base) {\n        digitB += Math.floor(digitA / base);\n        digitA %= base;\n    }\n    if (digitB >= base) {\n        digitC += Math.floor(digitB / base);\n        digitB %= base;\n    }\n    // Convert base-1e7 digits to base-10, with optional leading zeroes.\n    function decimalFrom1e7(digit1e7, needLeadingZeros) {\n        let partial = digit1e7 ? String(digit1e7) : '';\n        if (needLeadingZeros) {\n            return '0000000'.slice(partial.length) + partial;\n        }\n        return partial;\n    }\n    return decimalFrom1e7(digitC, /*needLeadingZeros=*/ 0) +\n        decimalFrom1e7(digitB, /*needLeadingZeros=*/ digitC) +\n        // If the final 1e7 digit didn't need leading zeros, we would have\n        // returned via the trivial code path at the top.\n        decimalFrom1e7(digitA, /*needLeadingZeros=*/ 1);\n}\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */\nexport function varint32write(value, bytes) {\n    if (value >= 0) {\n        // write value as varint 32\n        while (value > 0x7f) {\n            bytes.push((value & 0x7f) | 0x80);\n            value = value >>> 7;\n        }\n        bytes.push(value);\n    }\n    else {\n        for (let i = 0; i < 9; i++) {\n            bytes.push(value & 127 | 128);\n            value = value >> 7;\n        }\n        bytes.push(1);\n    }\n}\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */\nexport function varint32read() {\n    let b = this.buf[this.pos++];\n    let result = b & 0x7F;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7F) << 7;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7F) << 14;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7F) << 21;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    // Extract only last 4 bits\n    b = this.buf[this.pos++];\n    result |= (b & 0x0F) << 28;\n    for (let readBytes = 5; ((b & 0x80) !== 0) && readBytes < 10; readBytes++)\n        b = this.buf[this.pos++];\n    if ((b & 0x80) != 0)\n        throw new Error('invalid varint');\n    this.assertBounds();\n    // Result can have 32 bits, convert it to unsigned\n    return result >>> 0;\n}\n","import { int64fromString, int64toString } from \"./goog-varint\";\nlet BI;\nexport function detectBi() {\n    const dv = new DataView(new ArrayBuffer(8));\n    const ok = globalThis.BigInt !== undefined\n        && typeof dv.getBigInt64 === \"function\"\n        && typeof dv.getBigUint64 === \"function\"\n        && typeof dv.setBigInt64 === \"function\"\n        && typeof dv.setBigUint64 === \"function\";\n    BI = ok ? {\n        MIN: BigInt(\"-9223372036854775808\"),\n        MAX: BigInt(\"9223372036854775807\"),\n        UMIN: BigInt(\"0\"),\n        UMAX: BigInt(\"18446744073709551615\"),\n        C: BigInt,\n        V: dv,\n    } : undefined;\n}\ndetectBi();\nfunction assertBi(bi) {\n    if (!bi)\n        throw new Error(\"BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support\");\n}\n// used to validate from(string) input (when bigint is unavailable)\nconst RE_DECIMAL_STR = /^-?[0-9]+$/;\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\nconst HALF_2_PWR_32 = 0x080000000;\n// base class for PbLong and PbULong provides shared code\nclass SharedPbLong {\n    /**\n     * Create a new instance with the given bits.\n     */\n    constructor(lo, hi) {\n        this.lo = lo | 0;\n        this.hi = hi | 0;\n    }\n    /**\n     * Is this instance equal to 0?\n     */\n    isZero() {\n        return this.lo == 0 && this.hi == 0;\n    }\n    /**\n     * Convert to a native number.\n     */\n    toNumber() {\n        let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);\n        if (!Number.isSafeInteger(result))\n            throw new Error(\"cannot convert to safe number\");\n        return result;\n    }\n}\n/**\n * 64-bit unsigned integer as two 32-bit values.\n * Converts between `string`, `number` and `bigint` representations.\n */\nexport class PbULong extends SharedPbLong {\n    /**\n     * Create instance from a `string`, `number` or `bigint`.\n     */\n    static from(value) {\n        if (BI)\n            // noinspection FallThroughInSwitchStatementJS\n            switch (typeof value) {\n                case \"string\":\n                    if (value == \"0\")\n                        return this.ZERO;\n                    if (value == \"\")\n                        throw new Error('string is no integer');\n                    value = BI.C(value);\n                case \"number\":\n                    if (value === 0)\n                        return this.ZERO;\n                    value = BI.C(value);\n                case \"bigint\":\n                    if (!value)\n                        return this.ZERO;\n                    if (value < BI.UMIN)\n                        throw new Error('signed value for ulong');\n                    if (value > BI.UMAX)\n                        throw new Error('ulong too large');\n                    BI.V.setBigUint64(0, value, true);\n                    return new PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));\n            }\n        else\n            switch (typeof value) {\n                case \"string\":\n                    if (value == \"0\")\n                        return this.ZERO;\n                    value = value.trim();\n                    if (!RE_DECIMAL_STR.test(value))\n                        throw new Error('string is no integer');\n                    let [minus, lo, hi] = int64fromString(value);\n                    if (minus)\n                        throw new Error('signed value for ulong');\n                    return new PbULong(lo, hi);\n                case \"number\":\n                    if (value == 0)\n                        return this.ZERO;\n                    if (!Number.isSafeInteger(value))\n                        throw new Error('number is no integer');\n                    if (value < 0)\n                        throw new Error('signed value for ulong');\n                    return new PbULong(value, value / TWO_PWR_32_DBL);\n            }\n        throw new Error('unknown value ' + typeof value);\n    }\n    /**\n     * Convert to decimal string.\n     */\n    toString() {\n        return BI ? this.toBigInt().toString() : int64toString(this.lo, this.hi);\n    }\n    /**\n     * Convert to native bigint.\n     */\n    toBigInt() {\n        assertBi(BI);\n        BI.V.setInt32(0, this.lo, true);\n        BI.V.setInt32(4, this.hi, true);\n        return BI.V.getBigUint64(0, true);\n    }\n}\n/**\n * ulong 0 singleton.\n */\nPbULong.ZERO = new PbULong(0, 0);\n/**\n * 64-bit signed integer as two 32-bit values.\n * Converts between `string`, `number` and `bigint` representations.\n */\nexport class PbLong extends SharedPbLong {\n    /**\n     * Create instance from a `string`, `number` or `bigint`.\n     */\n    static from(value) {\n        if (BI)\n            // noinspection FallThroughInSwitchStatementJS\n            switch (typeof value) {\n                case \"string\":\n                    if (value == \"0\")\n                        return this.ZERO;\n                    if (value == \"\")\n                        throw new Error('string is no integer');\n                    value = BI.C(value);\n                case \"number\":\n                    if (value === 0)\n                        return this.ZERO;\n                    value = BI.C(value);\n                case \"bigint\":\n                    if (!value)\n                        return this.ZERO;\n                    if (value < BI.MIN)\n                        throw new Error('signed long too small');\n                    if (value > BI.MAX)\n                        throw new Error('signed long too large');\n                    BI.V.setBigInt64(0, value, true);\n                    return new PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));\n            }\n        else\n            switch (typeof value) {\n                case \"string\":\n                    if (value == \"0\")\n                        return this.ZERO;\n                    value = value.trim();\n                    if (!RE_DECIMAL_STR.test(value))\n                        throw new Error('string is no integer');\n                    let [minus, lo, hi] = int64fromString(value);\n                    if (minus) {\n                        if (hi > HALF_2_PWR_32 || (hi == HALF_2_PWR_32 && lo != 0))\n                            throw new Error('signed long too small');\n                    }\n                    else if (hi >= HALF_2_PWR_32)\n                        throw new Error('signed long too large');\n                    let pbl = new PbLong(lo, hi);\n                    return minus ? pbl.negate() : pbl;\n                case \"number\":\n                    if (value == 0)\n                        return this.ZERO;\n                    if (!Number.isSafeInteger(value))\n                        throw new Error('number is no integer');\n                    return value > 0\n                        ? new PbLong(value, value / TWO_PWR_32_DBL)\n                        : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();\n            }\n        throw new Error('unknown value ' + typeof value);\n    }\n    /**\n     * Do we have a minus sign?\n     */\n    isNegative() {\n        return (this.hi & HALF_2_PWR_32) !== 0;\n    }\n    /**\n     * Negate two's complement.\n     * Invert all the bits and add one to the result.\n     */\n    negate() {\n        let hi = ~this.hi, lo = this.lo;\n        if (lo)\n            lo = ~lo + 1;\n        else\n            hi += 1;\n        return new PbLong(lo, hi);\n    }\n    /**\n     * Convert to decimal string.\n     */\n    toString() {\n        if (BI)\n            return this.toBigInt().toString();\n        if (this.isNegative()) {\n            let n = this.negate();\n            return '-' + int64toString(n.lo, n.hi);\n        }\n        return int64toString(this.lo, this.hi);\n    }\n    /**\n     * Convert to native bigint.\n     */\n    toBigInt() {\n        assertBi(BI);\n        BI.V.setInt32(0, this.lo, true);\n        BI.V.setInt32(4, this.hi, true);\n        return BI.V.getBigInt64(0, true);\n    }\n}\n/**\n * long 0 singleton.\n */\nPbLong.ZERO = new PbLong(0, 0);\n","import { WireType } from \"./binary-format-contract\";\nimport { PbLong, PbULong } from \"./pb-long\";\nimport { varint32read, varint64read } from \"./goog-varint\";\nconst defaultsRead = {\n    readUnknownField: true,\n    readerFactory: bytes => new BinaryReader(bytes),\n};\n/**\n * Make options for reading binary data form partial options.\n */\nexport function binaryReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;\n}\nexport class BinaryReader {\n    constructor(buf, textDecoder) {\n        this.varint64 = varint64read; // dirty cast for `this`\n        /**\n         * Read a `uint32` field, an unsigned 32 bit varint.\n         */\n        this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`\n        this.buf = buf;\n        this.len = buf.length;\n        this.pos = 0;\n        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder(\"utf-8\", {\n            fatal: true,\n            ignoreBOM: true,\n        });\n    }\n    /**\n     * Reads a tag - field number and wire type.\n     */\n    tag() {\n        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;\n        if (fieldNo <= 0 || wireType < 0 || wireType > 5)\n            throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n        return [fieldNo, wireType];\n    }\n    /**\n     * Skip one element on the wire and return the skipped data.\n     * Supports WireType.StartGroup since v2.0.0-alpha.23.\n     */\n    skip(wireType) {\n        let start = this.pos;\n        // noinspection FallThroughInSwitchStatementJS\n        switch (wireType) {\n            case WireType.Varint:\n                while (this.buf[this.pos++] & 0x80) {\n                    // ignore\n                }\n                break;\n            case WireType.Bit64:\n                this.pos += 4;\n            case WireType.Bit32:\n                this.pos += 4;\n                break;\n            case WireType.LengthDelimited:\n                let len = this.uint32();\n                this.pos += len;\n                break;\n            case WireType.StartGroup:\n                // From descriptor.proto: Group type is deprecated, not supported in proto3.\n                // But we must still be able to parse and treat as unknown.\n                let t;\n                while ((t = this.tag()[1]) !== WireType.EndGroup) {\n                    this.skip(t);\n                }\n                break;\n            default:\n                throw new Error(\"cant skip wire type \" + wireType);\n        }\n        this.assertBounds();\n        return this.buf.subarray(start, this.pos);\n    }\n    /**\n     * Throws error if position in byte array is out of range.\n     */\n    assertBounds() {\n        if (this.pos > this.len)\n            throw new RangeError(\"premature EOF\");\n    }\n    /**\n     * Read a `int32` field, a signed 32 bit varint.\n     */\n    int32() {\n        return this.uint32() | 0;\n    }\n    /**\n     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n     */\n    sint32() {\n        let zze = this.uint32();\n        // decode zigzag\n        return (zze >>> 1) ^ -(zze & 1);\n    }\n    /**\n     * Read a `int64` field, a signed 64-bit varint.\n     */\n    int64() {\n        return new PbLong(...this.varint64());\n    }\n    /**\n     * Read a `uint64` field, an unsigned 64-bit varint.\n     */\n    uint64() {\n        return new PbULong(...this.varint64());\n    }\n    /**\n     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n     */\n    sint64() {\n        let [lo, hi] = this.varint64();\n        // decode zig zag\n        let s = -(lo & 1);\n        lo = ((lo >>> 1 | (hi & 1) << 31) ^ s);\n        hi = (hi >>> 1 ^ s);\n        return new PbLong(lo, hi);\n    }\n    /**\n     * Read a `bool` field, a variant.\n     */\n    bool() {\n        let [lo, hi] = this.varint64();\n        return lo !== 0 || hi !== 0;\n    }\n    /**\n     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n     */\n    fixed32() {\n        return this.view.getUint32((this.pos += 4) - 4, true);\n    }\n    /**\n     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n     */\n    sfixed32() {\n        return this.view.getInt32((this.pos += 4) - 4, true);\n    }\n    /**\n     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n     */\n    fixed64() {\n        return new PbULong(this.sfixed32(), this.sfixed32());\n    }\n    /**\n     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n     */\n    sfixed64() {\n        return new PbLong(this.sfixed32(), this.sfixed32());\n    }\n    /**\n     * Read a `float` field, 32-bit floating point number.\n     */\n    float() {\n        return this.view.getFloat32((this.pos += 4) - 4, true);\n    }\n    /**\n     * Read a `double` field, a 64-bit floating point number.\n     */\n    double() {\n        return this.view.getFloat64((this.pos += 8) - 8, true);\n    }\n    /**\n     * Read a `bytes` field, length-delimited arbitrary data.\n     */\n    bytes() {\n        let len = this.uint32();\n        let start = this.pos;\n        this.pos += len;\n        this.assertBounds();\n        return this.buf.subarray(start, start + len);\n    }\n    /**\n     * Read a `string` field, length-delimited data converted to UTF-8 text.\n     */\n    string() {\n        return this.textDecoder.decode(this.bytes());\n    }\n}\n","/**\n * assert that condition is true or throw error (with message)\n */\nexport function assert(condition, msg) {\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\n/**\n * assert that value cannot exist = type `never`. throw runtime error if it does.\n */\nexport function assertNever(value, msg) {\n    throw new Error(msg !== null && msg !== void 0 ? msg : 'Unexpected object: ' + value);\n}\nconst FLOAT32_MAX = 3.4028234663852886e+38, FLOAT32_MIN = -3.4028234663852886e+38, UINT32_MAX = 0xFFFFFFFF, INT32_MAX = 0X7FFFFFFF, INT32_MIN = -0X80000000;\nexport function assertInt32(arg) {\n    if (typeof arg !== \"number\")\n        throw new Error('invalid int 32: ' + typeof arg);\n    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)\n        throw new Error('invalid int 32: ' + arg);\n}\nexport function assertUInt32(arg) {\n    if (typeof arg !== \"number\")\n        throw new Error('invalid uint 32: ' + typeof arg);\n    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)\n        throw new Error('invalid uint 32: ' + arg);\n}\nexport function assertFloat32(arg) {\n    if (typeof arg !== \"number\")\n        throw new Error('invalid float 32: ' + typeof arg);\n    if (!Number.isFinite(arg))\n        return;\n    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)\n        throw new Error('invalid float 32: ' + arg);\n}\n","import { PbLong, PbULong } from \"./pb-long\";\nimport { varint32write, varint64write } from \"./goog-varint\";\nimport { assertFloat32, assertInt32, assertUInt32 } from \"./assert\";\nconst defaultsWrite = {\n    writeUnknownFields: true,\n    writerFactory: () => new BinaryWriter(),\n};\n/**\n * Make options for writing binary data form partial options.\n */\nexport function binaryWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;\n}\nexport class BinaryWriter {\n    constructor(textEncoder) {\n        /**\n         * Previous fork states.\n         */\n        this.stack = [];\n        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\n        this.chunks = [];\n        this.buf = [];\n    }\n    /**\n     * Return all bytes written and reset this writer.\n     */\n    finish() {\n        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\n        let len = 0;\n        for (let i = 0; i < this.chunks.length; i++)\n            len += this.chunks[i].length;\n        let bytes = new Uint8Array(len);\n        let offset = 0;\n        for (let i = 0; i < this.chunks.length; i++) {\n            bytes.set(this.chunks[i], offset);\n            offset += this.chunks[i].length;\n        }\n        this.chunks = [];\n        return bytes;\n    }\n    /**\n     * Start a new fork for length-delimited data like a message\n     * or a packed repeated field.\n     *\n     * Must be joined later with `join()`.\n     */\n    fork() {\n        this.stack.push({ chunks: this.chunks, buf: this.buf });\n        this.chunks = [];\n        this.buf = [];\n        return this;\n    }\n    /**\n     * Join the last fork. Write its length and bytes, then\n     * return to the previous state.\n     */\n    join() {\n        // get chunk of fork\n        let chunk = this.finish();\n        // restore previous state\n        let prev = this.stack.pop();\n        if (!prev)\n            throw new Error('invalid state, fork stack empty');\n        this.chunks = prev.chunks;\n        this.buf = prev.buf;\n        // write length of chunk as varint\n        this.uint32(chunk.byteLength);\n        return this.raw(chunk);\n    }\n    /**\n     * Writes a tag (field number and wire type).\n     *\n     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n     *\n     * Generated code should compute the tag ahead of time and call `uint32()`.\n     */\n    tag(fieldNo, type) {\n        return this.uint32((fieldNo << 3 | type) >>> 0);\n    }\n    /**\n     * Write a chunk of raw bytes.\n     */\n    raw(chunk) {\n        if (this.buf.length) {\n            this.chunks.push(new Uint8Array(this.buf));\n            this.buf = [];\n        }\n        this.chunks.push(chunk);\n        return this;\n    }\n    /**\n     * Write a `uint32` value, an unsigned 32 bit varint.\n     */\n    uint32(value) {\n        assertUInt32(value);\n        // write value as varint 32, inlined for speed\n        while (value > 0x7f) {\n            this.buf.push((value & 0x7f) | 0x80);\n            value = value >>> 7;\n        }\n        this.buf.push(value);\n        return this;\n    }\n    /**\n     * Write a `int32` value, a signed 32 bit varint.\n     */\n    int32(value) {\n        assertInt32(value);\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n     * Write a `bool` value, a variant.\n     */\n    bool(value) {\n        this.buf.push(value ? 1 : 0);\n        return this;\n    }\n    /**\n     * Write a `bytes` value, length-delimited arbitrary data.\n     */\n    bytes(value) {\n        this.uint32(value.byteLength); // write length of chunk as varint\n        return this.raw(value);\n    }\n    /**\n     * Write a `string` value, length-delimited data converted to UTF-8 text.\n     */\n    string(value) {\n        let chunk = this.textEncoder.encode(value);\n        this.uint32(chunk.byteLength); // write length of chunk as varint\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `float` value, 32-bit floating point number.\n     */\n    float(value) {\n        assertFloat32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setFloat32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `double` value, a 64-bit floating point number.\n     */\n    double(value) {\n        let chunk = new Uint8Array(8);\n        new DataView(chunk.buffer).setFloat64(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n     */\n    fixed32(value) {\n        assertUInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setUint32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n     */\n    sfixed32(value) {\n        assertInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setInt32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n     */\n    sint32(value) {\n        assertInt32(value);\n        // zigzag encode\n        value = ((value << 1) ^ (value >> 31)) >>> 0;\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n     */\n    sfixed64(value) {\n        let chunk = new Uint8Array(8);\n        let view = new DataView(chunk.buffer);\n        let long = PbLong.from(value);\n        view.setInt32(0, long.lo, true);\n        view.setInt32(4, long.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n     */\n    fixed64(value) {\n        let chunk = new Uint8Array(8);\n        let view = new DataView(chunk.buffer);\n        let long = PbULong.from(value);\n        view.setInt32(0, long.lo, true);\n        view.setInt32(4, long.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `int64` value, a signed 64-bit varint.\n     */\n    int64(value) {\n        let long = PbLong.from(value);\n        varint64write(long.lo, long.hi, this.buf);\n        return this;\n    }\n    /**\n     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n     */\n    sint64(value) {\n        let long = PbLong.from(value), \n        // zigzag encode\n        sign = long.hi >> 31, lo = (long.lo << 1) ^ sign, hi = ((long.hi << 1) | (long.lo >>> 31)) ^ sign;\n        varint64write(lo, hi, this.buf);\n        return this;\n    }\n    /**\n     * Write a `uint64` value, an unsigned 64-bit varint.\n     */\n    uint64(value) {\n        let long = PbULong.from(value);\n        varint64write(long.lo, long.hi, this.buf);\n        return this;\n    }\n}\n","const defaultsWrite = {\n    emitDefaultValues: false,\n    enumAsInteger: false,\n    useProtoFieldName: false,\n    prettySpaces: 0,\n}, defaultsRead = {\n    ignoreUnknownFields: false,\n};\n/**\n * Make options for reading JSON data from partial options.\n */\nexport function jsonReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;\n}\n/**\n * Make options for writing JSON data from partial options.\n */\nexport function jsonWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;\n}\n/**\n * Merges JSON write or read options. Later values override earlier values. Type registries are merged.\n */\nexport function mergeJsonOptions(a, b) {\n    var _a, _b;\n    let c = Object.assign(Object.assign({}, a), b);\n    c.typeRegistry = [...((_a = a === null || a === void 0 ? void 0 : a.typeRegistry) !== null && _a !== void 0 ? _a : []), ...((_b = b === null || b === void 0 ? void 0 : b.typeRegistry) !== null && _b !== void 0 ? _b : [])];\n    return c;\n}\n","/**\n * The symbol used as a key on message objects to store the message type.\n *\n * Note that this is an experimental feature - it is here to stay, but\n * implementation details may change without notice.\n */\nexport const MESSAGE_TYPE = Symbol.for(\"protobuf-ts/message-type\");\n","/**\n * Converts snake_case to lowerCamelCase.\n *\n * Should behave like protoc:\n * https://github.com/protocolbuffers/protobuf/blob/e8ae137c96444ea313485ed1118c5e43b2099cf1/src/google/protobuf/compiler/java/java_helpers.cc#L118\n */\nexport function lowerCamelCase(snakeCase) {\n    let capNext = false;\n    const sb = [];\n    for (let i = 0; i < snakeCase.length; i++) {\n        let next = snakeCase.charAt(i);\n        if (next == '_') {\n            capNext = true;\n        }\n        else if (/\\d/.test(next)) {\n            sb.push(next);\n            capNext = true;\n        }\n        else if (capNext) {\n            sb.push(next.toUpperCase());\n            capNext = false;\n        }\n        else if (i == 0) {\n            sb.push(next.toLowerCase());\n        }\n        else {\n            sb.push(next);\n        }\n    }\n    return sb.join('');\n}\n","import { lowerCamelCase } from \"./lower-camel-case\";\n/**\n * Scalar value types. This is a subset of field types declared by protobuf\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\n * are omitted, but the numerical values are identical.\n */\nexport var ScalarType;\n(function (ScalarType) {\n    // 0 is reserved for errors.\n    // Order is weird for historical reasons.\n    ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n    ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\n    ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\n    ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\n    ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\n    ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\n    ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\n    // Tag-delimited aggregate.\n    // Group type is deprecated and not supported in proto3. However, Proto3\n    // implementations should still be able to parse the group wire format and\n    // treat group fields as unknown fields.\n    // TYPE_GROUP = 10,\n    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\n    // New in version 2.\n    ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\n    ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\n    // TYPE_ENUM = 14,\n    ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\n    ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\n    ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\n    ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\n})(ScalarType || (ScalarType = {}));\n/**\n * JavaScript representation of 64 bit integral types. Equivalent to the\n * field option \"jstype\".\n *\n * By default, protobuf-ts represents 64 bit types as `bigint`.\n *\n * You can change the default behaviour by enabling the plugin parameter\n * `long_type_string`, which will represent 64 bit types as `string`.\n *\n * Alternatively, you can change the behaviour for individual fields\n * with the field option \"jstype\":\n *\n * ```protobuf\n * uint64 my_field = 1 [jstype = JS_STRING];\n * uint64 other_field = 2 [jstype = JS_NUMBER];\n * ```\n */\nexport var LongType;\n(function (LongType) {\n    /**\n     * Use JavaScript `bigint`.\n     *\n     * Field option `[jstype = JS_NORMAL]`.\n     */\n    LongType[LongType[\"BIGINT\"] = 0] = \"BIGINT\";\n    /**\n     * Use JavaScript `string`.\n     *\n     * Field option `[jstype = JS_STRING]`.\n     */\n    LongType[LongType[\"STRING\"] = 1] = \"STRING\";\n    /**\n     * Use JavaScript `number`.\n     *\n     * Large values will loose precision.\n     *\n     * Field option `[jstype = JS_NUMBER]`.\n     */\n    LongType[LongType[\"NUMBER\"] = 2] = \"NUMBER\";\n})(LongType || (LongType = {}));\n/**\n * Protobuf 2.1.0 introduced packed repeated fields.\n * Setting the field option `[packed = true]` enables packing.\n *\n * In proto3, all repeated fields are packed by default.\n * Setting the field option `[packed = false]` disables packing.\n *\n * Packed repeated fields are encoded with a single tag,\n * then a length-delimiter, then the element values.\n *\n * Unpacked repeated fields are encoded with a tag and\n * value for each element.\n *\n * `bytes` and `string` cannot be packed.\n */\nexport var RepeatType;\n(function (RepeatType) {\n    /**\n     * The field is not repeated.\n     */\n    RepeatType[RepeatType[\"NO\"] = 0] = \"NO\";\n    /**\n     * The field is repeated and should be packed.\n     * Invalid for `bytes` and `string`, they cannot be packed.\n     */\n    RepeatType[RepeatType[\"PACKED\"] = 1] = \"PACKED\";\n    /**\n     * The field is repeated but should not be packed.\n     * The only valid repeat type for repeated `bytes` and `string`.\n     */\n    RepeatType[RepeatType[\"UNPACKED\"] = 2] = \"UNPACKED\";\n})(RepeatType || (RepeatType = {}));\n/**\n * Turns PartialFieldInfo into FieldInfo.\n */\nexport function normalizeFieldInfo(field) {\n    var _a, _b, _c, _d;\n    field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(field.name);\n    field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : lowerCamelCase(field.name);\n    field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;\n    field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : (field.repeat ? false : field.oneof ? false : field.kind == \"message\");\n    return field;\n}\n/**\n * Read custom field options from a generated message type.\n *\n * @deprecated use readFieldOption()\n */\nexport function readFieldOptions(messageType, fieldName, extensionName, extensionType) {\n    var _a;\n    const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;\n    return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : undefined;\n}\nexport function readFieldOption(messageType, fieldName, extensionName, extensionType) {\n    var _a;\n    const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;\n    if (!options) {\n        return undefined;\n    }\n    const optionVal = options[extensionName];\n    if (optionVal === undefined) {\n        return optionVal;\n    }\n    return extensionType ? extensionType.fromJson(optionVal) : optionVal;\n}\nexport function readMessageOption(messageType, extensionName, extensionType) {\n    const options = messageType.options;\n    const optionVal = options[extensionName];\n    if (optionVal === undefined) {\n        return optionVal;\n    }\n    return extensionType ? extensionType.fromJson(optionVal) : optionVal;\n}\n","/**\n * Is the given value a valid oneof group?\n *\n * We represent protobuf `oneof` as algebraic data types (ADT) in generated\n * code. But when working with messages of unknown type, the ADT does not\n * help us.\n *\n * This type guard checks if the given object adheres to the ADT rules, which\n * are as follows:\n *\n * 1) Must be an object.\n *\n * 2) Must have a \"oneofKind\" discriminator property.\n *\n * 3) If \"oneofKind\" is `undefined`, no member field is selected. The object\n * must not have any other properties.\n *\n * 4) If \"oneofKind\" is a `string`, the member field with this name is\n * selected.\n *\n * 5) If a member field is selected, the object must have a second property\n * with this name. The property must not be `undefined`.\n *\n * 6) No extra properties are allowed. The object has either one property\n * (no selection) or two properties (selection).\n *\n */\nexport function isOneofGroup(any) {\n    if (typeof any != 'object' || any === null || !any.hasOwnProperty('oneofKind')) {\n        return false;\n    }\n    switch (typeof any.oneofKind) {\n        case \"string\":\n            if (any[any.oneofKind] === undefined)\n                return false;\n            return Object.keys(any).length == 2;\n        case \"undefined\":\n            return Object.keys(any).length == 1;\n        default:\n            return false;\n    }\n}\n/**\n * Returns the value of the given field in a oneof group.\n */\nexport function getOneofValue(oneof, kind) {\n    return oneof[kind];\n}\nexport function setOneofValue(oneof, kind, value) {\n    if (oneof.oneofKind !== undefined) {\n        delete oneof[oneof.oneofKind];\n    }\n    oneof.oneofKind = kind;\n    if (value !== undefined) {\n        oneof[kind] = value;\n    }\n}\nexport function setUnknownOneofValue(oneof, kind, value) {\n    if (oneof.oneofKind !== undefined) {\n        delete oneof[oneof.oneofKind];\n    }\n    oneof.oneofKind = kind;\n    if (value !== undefined && kind !== undefined) {\n        oneof[kind] = value;\n    }\n}\n/**\n * Removes the selected field in a oneof group.\n *\n * Note that the recommended way to modify a oneof group is to set\n * a new object:\n *\n * ```ts\n * message.result = { oneofKind: undefined };\n * ```\n */\nexport function clearOneofValue(oneof) {\n    if (oneof.oneofKind !== undefined) {\n        delete oneof[oneof.oneofKind];\n    }\n    oneof.oneofKind = undefined;\n}\n/**\n * Returns the selected value of the given oneof group.\n *\n * Not that the recommended way to access a oneof group is to check\n * the \"oneofKind\" property and let TypeScript narrow down the union\n * type for you:\n *\n * ```ts\n * if (message.result.oneofKind === \"error\") {\n *   message.result.error; // string\n * }\n * ```\n *\n * In the rare case you just need the value, and do not care about\n * which protobuf field is selected, you can use this function\n * for convenience.\n */\nexport function getSelectedOneofValue(oneof) {\n    if (oneof.oneofKind === undefined) {\n        return undefined;\n    }\n    return oneof[oneof.oneofKind];\n}\n","import { LongType, ScalarType } from \"./reflection-info\";\nimport { isOneofGroup } from \"./oneof\";\n// noinspection JSMethodCanBeStatic\nexport class ReflectionTypeCheck {\n    constructor(info) {\n        var _a;\n        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];\n    }\n    prepare() {\n        if (this.data)\n            return;\n        const req = [], known = [], oneofs = [];\n        for (let field of this.fields) {\n            if (field.oneof) {\n                if (!oneofs.includes(field.oneof)) {\n                    oneofs.push(field.oneof);\n                    req.push(field.oneof);\n                    known.push(field.oneof);\n                }\n            }\n            else {\n                known.push(field.localName);\n                switch (field.kind) {\n                    case \"scalar\":\n                    case \"enum\":\n                        if (!field.opt || field.repeat)\n                            req.push(field.localName);\n                        break;\n                    case \"message\":\n                        if (field.repeat)\n                            req.push(field.localName);\n                        break;\n                    case \"map\":\n                        req.push(field.localName);\n                        break;\n                }\n            }\n        }\n        this.data = { req, known, oneofs: Object.values(oneofs) };\n    }\n    /**\n     * Is the argument a valid message as specified by the\n     * reflection information?\n     *\n     * Checks all field types recursively. The `depth`\n     * specifies how deep into the structure the check will be.\n     *\n     * With a depth of 0, only the presence of fields\n     * is checked.\n     *\n     * With a depth of 1 or more, the field types are checked.\n     *\n     * With a depth of 2 or more, the members of map, repeated\n     * and message fields are checked.\n     *\n     * Message fields will be checked recursively with depth - 1.\n     *\n     * The number of map entries / repeated values being checked\n     * is < depth.\n     */\n    is(message, depth, allowExcessProperties = false) {\n        if (depth < 0)\n            return true;\n        if (message === null || message === undefined || typeof message != 'object')\n            return false;\n        this.prepare();\n        let keys = Object.keys(message), data = this.data;\n        // if a required field is missing in arg, this cannot be a T\n        if (keys.length < data.req.length || data.req.some(n => !keys.includes(n)))\n            return false;\n        if (!allowExcessProperties) {\n            // if the arg contains a key we dont know, this is not a literal T\n            if (keys.some(k => !data.known.includes(k)))\n                return false;\n        }\n        // \"With a depth of 0, only the presence and absence of fields is checked.\"\n        // \"With a depth of 1 or more, the field types are checked.\"\n        if (depth < 1) {\n            return true;\n        }\n        // check oneof group\n        for (const name of data.oneofs) {\n            const group = message[name];\n            if (!isOneofGroup(group))\n                return false;\n            if (group.oneofKind === undefined)\n                continue;\n            const field = this.fields.find(f => f.localName === group.oneofKind);\n            if (!field)\n                return false; // we found no field, but have a kind, something is wrong\n            if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))\n                return false;\n        }\n        // check types\n        for (const field of this.fields) {\n            if (field.oneof !== undefined)\n                continue;\n            if (!this.field(message[field.localName], field, allowExcessProperties, depth))\n                return false;\n        }\n        return true;\n    }\n    field(arg, field, allowExcessProperties, depth) {\n        let repeated = field.repeat;\n        switch (field.kind) {\n            case \"scalar\":\n                if (arg === undefined)\n                    return field.opt;\n                if (repeated)\n                    return this.scalars(arg, field.T, depth, field.L);\n                return this.scalar(arg, field.T, field.L);\n            case \"enum\":\n                if (arg === undefined)\n                    return field.opt;\n                if (repeated)\n                    return this.scalars(arg, ScalarType.INT32, depth);\n                return this.scalar(arg, ScalarType.INT32);\n            case \"message\":\n                if (arg === undefined)\n                    return true;\n                if (repeated)\n                    return this.messages(arg, field.T(), allowExcessProperties, depth);\n                return this.message(arg, field.T(), allowExcessProperties, depth);\n            case \"map\":\n                if (typeof arg != 'object' || arg === null)\n                    return false;\n                if (depth < 2)\n                    return true;\n                if (!this.mapKeys(arg, field.K, depth))\n                    return false;\n                switch (field.V.kind) {\n                    case \"scalar\":\n                        return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);\n                    case \"enum\":\n                        return this.scalars(Object.values(arg), ScalarType.INT32, depth);\n                    case \"message\":\n                        return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);\n                }\n                break;\n        }\n        return true;\n    }\n    message(arg, type, allowExcessProperties, depth) {\n        if (allowExcessProperties) {\n            return type.isAssignable(arg, depth);\n        }\n        return type.is(arg, depth);\n    }\n    messages(arg, type, allowExcessProperties, depth) {\n        if (!Array.isArray(arg))\n            return false;\n        if (depth < 2)\n            return true;\n        if (allowExcessProperties) {\n            for (let i = 0; i < arg.length && i < depth; i++)\n                if (!type.isAssignable(arg[i], depth - 1))\n                    return false;\n        }\n        else {\n            for (let i = 0; i < arg.length && i < depth; i++)\n                if (!type.is(arg[i], depth - 1))\n                    return false;\n        }\n        return true;\n    }\n    scalar(arg, type, longType) {\n        let argType = typeof arg;\n        switch (type) {\n            case ScalarType.UINT64:\n            case ScalarType.FIXED64:\n            case ScalarType.INT64:\n            case ScalarType.SFIXED64:\n            case ScalarType.SINT64:\n                switch (longType) {\n                    case LongType.BIGINT:\n                        return argType == \"bigint\";\n                    case LongType.NUMBER:\n                        return argType == \"number\" && !isNaN(arg);\n                    default:\n                        return argType == \"string\";\n                }\n            case ScalarType.BOOL:\n                return argType == 'boolean';\n            case ScalarType.STRING:\n                return argType == 'string';\n            case ScalarType.BYTES:\n                return arg instanceof Uint8Array;\n            case ScalarType.DOUBLE:\n            case ScalarType.FLOAT:\n                return argType == 'number' && !isNaN(arg);\n            default:\n                // case ScalarType.UINT32:\n                // case ScalarType.FIXED32:\n                // case ScalarType.INT32:\n                // case ScalarType.SINT32:\n                // case ScalarType.SFIXED32:\n                return argType == 'number' && Number.isInteger(arg);\n        }\n    }\n    scalars(arg, type, depth, longType) {\n        if (!Array.isArray(arg))\n            return false;\n        if (depth < 2)\n            return true;\n        if (Array.isArray(arg))\n            for (let i = 0; i < arg.length && i < depth; i++)\n                if (!this.scalar(arg[i], type, longType))\n                    return false;\n        return true;\n    }\n    mapKeys(map, type, depth) {\n        let keys = Object.keys(map);\n        switch (type) {\n            case ScalarType.INT32:\n            case ScalarType.FIXED32:\n            case ScalarType.SFIXED32:\n            case ScalarType.SINT32:\n            case ScalarType.UINT32:\n                return this.scalars(keys.slice(0, depth).map(k => parseInt(k)), type, depth);\n            case ScalarType.BOOL:\n                return this.scalars(keys.slice(0, depth).map(k => k == 'true' ? true : k == 'false' ? false : k), type, depth);\n            default:\n                return this.scalars(keys, type, depth, LongType.STRING);\n        }\n    }\n}\n","import { LongType } from \"./reflection-info\";\n/**\n * Utility method to convert a PbLong or PbUlong to a JavaScript\n * representation during runtime.\n *\n * Works with generated field information, `undefined` is equivalent\n * to `STRING`.\n */\nexport function reflectionLongConvert(long, type) {\n    switch (type) {\n        case LongType.BIGINT:\n            return long.toBigInt();\n        case LongType.NUMBER:\n            return long.toNumber();\n        default:\n            // case undefined:\n            // case LongType.STRING:\n            return long.toString();\n    }\n}\n","import { isJsonObject, typeofJsonValue } from \"./json-typings\";\nimport { base64decode } from \"./base64\";\nimport { LongType, ScalarType } from \"./reflection-info\";\nimport { PbLong, PbULong } from \"./pb-long\";\nimport { assert, assertFloat32, assertInt32, assertUInt32 } from \"./assert\";\nimport { reflectionLongConvert } from \"./reflection-long-convert\";\n/**\n * Reads proto3 messages in canonical JSON format using reflection information.\n *\n * https://developers.google.com/protocol-buffers/docs/proto3#json\n */\nexport class ReflectionJsonReader {\n    constructor(info) {\n        this.info = info;\n    }\n    prepare() {\n        var _a;\n        if (this.fMap === undefined) {\n            this.fMap = {};\n            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];\n            for (const field of fieldsInput) {\n                this.fMap[field.name] = field;\n                this.fMap[field.jsonName] = field;\n                this.fMap[field.localName] = field;\n            }\n        }\n    }\n    // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.\n    assert(condition, fieldName, jsonValue) {\n        if (!condition) {\n            let what = typeofJsonValue(jsonValue);\n            if (what == \"number\" || what == \"boolean\")\n                what = jsonValue.toString();\n            throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);\n        }\n    }\n    /**\n     * Reads a message from canonical JSON format into the target message.\n     *\n     * Repeated fields are appended. Map entries are added, overwriting\n     * existing keys.\n     *\n     * If a message field is already present, it will be merged with the\n     * new data.\n     */\n    read(input, message, options) {\n        this.prepare();\n        const oneofsHandled = [];\n        for (const [jsonKey, jsonValue] of Object.entries(input)) {\n            const field = this.fMap[jsonKey];\n            if (!field) {\n                if (!options.ignoreUnknownFields)\n                    throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);\n                continue;\n            }\n            const localName = field.localName;\n            // handle oneof ADT\n            let target; // this will be the target for the field value, whether it is member of a oneof or not\n            if (field.oneof) {\n                if (jsonValue === null && (field.kind !== 'enum' || field.T()[0] !== 'google.protobuf.NullValue')) {\n                    continue;\n                }\n                // since json objects are unordered by specification, it is not possible to take the last of multiple oneofs\n                if (oneofsHandled.includes(field.oneof))\n                    throw new Error(`Multiple members of the oneof group \"${field.oneof}\" of ${this.info.typeName} are present in JSON.`);\n                oneofsHandled.push(field.oneof);\n                target = message[field.oneof] = {\n                    oneofKind: localName\n                };\n            }\n            else {\n                target = message;\n            }\n            // we have handled oneof above. we just have read the value into `target`.\n            if (field.kind == 'map') {\n                if (jsonValue === null) {\n                    continue;\n                }\n                // check input\n                this.assert(isJsonObject(jsonValue), field.name, jsonValue);\n                // our target to put map entries into\n                const fieldObj = target[localName];\n                // read entries\n                for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {\n                    this.assert(jsonObjValue !== null, field.name + \" map value\", null);\n                    // read value\n                    let val;\n                    switch (field.V.kind) {\n                        case \"message\":\n                            val = field.V.T().internalJsonRead(jsonObjValue, options);\n                            break;\n                        case \"enum\":\n                            val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);\n                            if (val === false)\n                                continue;\n                            break;\n                        case \"scalar\":\n                            val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);\n                            break;\n                    }\n                    this.assert(val !== undefined, field.name + \" map value\", jsonObjValue);\n                    // read key\n                    let key = jsonObjKey;\n                    if (field.K == ScalarType.BOOL)\n                        key = key == \"true\" ? true : key == \"false\" ? false : key;\n                    key = this.scalar(key, field.K, LongType.STRING, field.name).toString();\n                    fieldObj[key] = val;\n                }\n            }\n            else if (field.repeat) {\n                if (jsonValue === null)\n                    continue;\n                // check input\n                this.assert(Array.isArray(jsonValue), field.name, jsonValue);\n                // our target to put array entries into\n                const fieldArr = target[localName];\n                // read array entries\n                for (const jsonItem of jsonValue) {\n                    this.assert(jsonItem !== null, field.name, null);\n                    let val;\n                    switch (field.kind) {\n                        case \"message\":\n                            val = field.T().internalJsonRead(jsonItem, options);\n                            break;\n                        case \"enum\":\n                            val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);\n                            if (val === false)\n                                continue;\n                            break;\n                        case \"scalar\":\n                            val = this.scalar(jsonItem, field.T, field.L, field.name);\n                            break;\n                    }\n                    this.assert(val !== undefined, field.name, jsonValue);\n                    fieldArr.push(val);\n                }\n            }\n            else {\n                switch (field.kind) {\n                    case \"message\":\n                        if (jsonValue === null && field.T().typeName != 'google.protobuf.Value') {\n                            this.assert(field.oneof === undefined, field.name + \" (oneof member)\", null);\n                            continue;\n                        }\n                        target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);\n                        break;\n                    case \"enum\":\n                        let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);\n                        if (val === false)\n                            continue;\n                        target[localName] = val;\n                        break;\n                    case \"scalar\":\n                        target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);\n                        break;\n                }\n            }\n        }\n    }\n    /**\n     * Returns `false` for unrecognized string representations.\n     *\n     * google.protobuf.NullValue accepts only JSON `null` (or the old `\"NULL_VALUE\"`).\n     */\n    enum(type, json, fieldName, ignoreUnknownFields) {\n        if (type[0] == 'google.protobuf.NullValue')\n            assert(json === null || json === \"NULL_VALUE\", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);\n        if (json === null)\n            // we require 0 to be default value for all enums\n            return 0;\n        switch (typeof json) {\n            case \"number\":\n                assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);\n                return json;\n            case \"string\":\n                let localEnumName = json;\n                if (type[2] && json.substring(0, type[2].length) === type[2])\n                    // lookup without the shared prefix\n                    localEnumName = json.substring(type[2].length);\n                let enumNumber = type[1][localEnumName];\n                if (typeof enumNumber === 'undefined' && ignoreUnknownFields) {\n                    return false;\n                }\n                assert(typeof enumNumber == \"number\", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for \"${json}\".`);\n                return enumNumber;\n        }\n        assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}\".`);\n    }\n    scalar(json, type, longType, fieldName) {\n        let e;\n        try {\n            switch (type) {\n                // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n                // Either numbers or strings are accepted. Exponent notation is also accepted.\n                case ScalarType.DOUBLE:\n                case ScalarType.FLOAT:\n                    if (json === null)\n                        return .0;\n                    if (json === \"NaN\")\n                        return Number.NaN;\n                    if (json === \"Infinity\")\n                        return Number.POSITIVE_INFINITY;\n                    if (json === \"-Infinity\")\n                        return Number.NEGATIVE_INFINITY;\n                    if (json === \"\") {\n                        e = \"empty string\";\n                        break;\n                    }\n                    if (typeof json == \"string\" && json.trim().length !== json.length) {\n                        e = \"extra whitespace\";\n                        break;\n                    }\n                    if (typeof json != \"string\" && typeof json != \"number\") {\n                        break;\n                    }\n                    let float = Number(json);\n                    if (Number.isNaN(float)) {\n                        e = \"not a number\";\n                        break;\n                    }\n                    if (!Number.isFinite(float)) {\n                        // infinity and -infinity are handled by string representation above, so this is an error\n                        e = \"too large or small\";\n                        break;\n                    }\n                    if (type == ScalarType.FLOAT)\n                        assertFloat32(float);\n                    return float;\n                // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n                case ScalarType.INT32:\n                case ScalarType.FIXED32:\n                case ScalarType.SFIXED32:\n                case ScalarType.SINT32:\n                case ScalarType.UINT32:\n                    if (json === null)\n                        return 0;\n                    let int32;\n                    if (typeof json == \"number\")\n                        int32 = json;\n                    else if (json === \"\")\n                        e = \"empty string\";\n                    else if (typeof json == \"string\") {\n                        if (json.trim().length !== json.length)\n                            e = \"extra whitespace\";\n                        else\n                            int32 = Number(json);\n                    }\n                    if (int32 === undefined)\n                        break;\n                    if (type == ScalarType.UINT32)\n                        assertUInt32(int32);\n                    else\n                        assertInt32(int32);\n                    return int32;\n                // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\n                case ScalarType.INT64:\n                case ScalarType.SFIXED64:\n                case ScalarType.SINT64:\n                    if (json === null)\n                        return reflectionLongConvert(PbLong.ZERO, longType);\n                    if (typeof json != \"number\" && typeof json != \"string\")\n                        break;\n                    return reflectionLongConvert(PbLong.from(json), longType);\n                case ScalarType.FIXED64:\n                case ScalarType.UINT64:\n                    if (json === null)\n                        return reflectionLongConvert(PbULong.ZERO, longType);\n                    if (typeof json != \"number\" && typeof json != \"string\")\n                        break;\n                    return reflectionLongConvert(PbULong.from(json), longType);\n                // bool:\n                case ScalarType.BOOL:\n                    if (json === null)\n                        return false;\n                    if (typeof json !== \"boolean\")\n                        break;\n                    return json;\n                // string:\n                case ScalarType.STRING:\n                    if (json === null)\n                        return \"\";\n                    if (typeof json !== \"string\") {\n                        e = \"extra whitespace\";\n                        break;\n                    }\n                    try {\n                        encodeURIComponent(json);\n                    }\n                    catch (e) {\n                        e = \"invalid UTF8\";\n                        break;\n                    }\n                    return json;\n                // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n                // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n                case ScalarType.BYTES:\n                    if (json === null || json === \"\")\n                        return new Uint8Array(0);\n                    if (typeof json !== 'string')\n                        break;\n                    return base64decode(json);\n            }\n        }\n        catch (error) {\n            e = error.message;\n        }\n        this.assert(false, fieldName + (e ? \" - \" + e : \"\"), json);\n    }\n}\n","import { base64encode } from \"./base64\";\nimport { PbLong, PbULong } from \"./pb-long\";\nimport { ScalarType } from \"./reflection-info\";\nimport { assert, assertFloat32, assertInt32, assertUInt32 } from \"./assert\";\n/**\n * Writes proto3 messages in canonical JSON format using reflection\n * information.\n *\n * https://developers.google.com/protocol-buffers/docs/proto3#json\n */\nexport class ReflectionJsonWriter {\n    constructor(info) {\n        var _a;\n        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];\n    }\n    /**\n     * Converts the message to a JSON object, based on the field descriptors.\n     */\n    write(message, options) {\n        const json = {}, source = message;\n        for (const field of this.fields) {\n            // field is not part of a oneof, simply write as is\n            if (!field.oneof) {\n                let jsonValue = this.field(field, source[field.localName], options);\n                if (jsonValue !== undefined)\n                    json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\n                continue;\n            }\n            // field is part of a oneof\n            const group = source[field.oneof];\n            if (group.oneofKind !== field.localName)\n                continue; // not selected, skip\n            const opt = field.kind == 'scalar' || field.kind == 'enum'\n                ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;\n            let jsonValue = this.field(field, group[field.localName], opt);\n            assert(jsonValue !== undefined);\n            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\n        }\n        return json;\n    }\n    field(field, value, options) {\n        let jsonValue = undefined;\n        if (field.kind == 'map') {\n            assert(typeof value == \"object\" && value !== null);\n            const jsonObj = {};\n            switch (field.V.kind) {\n                case \"scalar\":\n                    for (const [entryKey, entryValue] of Object.entries(value)) {\n                        const val = this.scalar(field.V.T, entryValue, field.name, false, true);\n                        assert(val !== undefined);\n                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                    }\n                    break;\n                case \"message\":\n                    const messageType = field.V.T();\n                    for (const [entryKey, entryValue] of Object.entries(value)) {\n                        const val = this.message(messageType, entryValue, field.name, options);\n                        assert(val !== undefined);\n                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                    }\n                    break;\n                case \"enum\":\n                    const enumInfo = field.V.T();\n                    for (const [entryKey, entryValue] of Object.entries(value)) {\n                        assert(entryValue === undefined || typeof entryValue == 'number');\n                        const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);\n                        assert(val !== undefined);\n                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                    }\n                    break;\n            }\n            if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)\n                jsonValue = jsonObj;\n        }\n        else if (field.repeat) {\n            assert(Array.isArray(value));\n            const jsonArr = [];\n            switch (field.kind) {\n                case \"scalar\":\n                    for (let i = 0; i < value.length; i++) {\n                        const val = this.scalar(field.T, value[i], field.name, field.opt, true);\n                        assert(val !== undefined);\n                        jsonArr.push(val);\n                    }\n                    break;\n                case \"enum\":\n                    const enumInfo = field.T();\n                    for (let i = 0; i < value.length; i++) {\n                        assert(value[i] === undefined || typeof value[i] == 'number');\n                        const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);\n                        assert(val !== undefined);\n                        jsonArr.push(val);\n                    }\n                    break;\n                case \"message\":\n                    const messageType = field.T();\n                    for (let i = 0; i < value.length; i++) {\n                        const val = this.message(messageType, value[i], field.name, options);\n                        assert(val !== undefined);\n                        jsonArr.push(val);\n                    }\n                    break;\n            }\n            // add converted array to json output\n            if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)\n                jsonValue = jsonArr;\n        }\n        else {\n            switch (field.kind) {\n                case \"scalar\":\n                    jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);\n                    break;\n                case \"enum\":\n                    jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);\n                    break;\n                case \"message\":\n                    jsonValue = this.message(field.T(), value, field.name, options);\n                    break;\n            }\n        }\n        return jsonValue;\n    }\n    /**\n     * Returns `null` as the default for google.protobuf.NullValue.\n     */\n    enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {\n        if (type[0] == 'google.protobuf.NullValue')\n            return !emitDefaultValues && !optional ? undefined : null;\n        if (value === undefined) {\n            assert(optional);\n            return undefined;\n        }\n        if (value === 0 && !emitDefaultValues && !optional)\n            // we require 0 to be default value for all enums\n            return undefined;\n        assert(typeof value == 'number');\n        assert(Number.isInteger(value));\n        if (enumAsInteger || !type[1].hasOwnProperty(value))\n            // if we don't now the enum value, just return the number\n            return value;\n        if (type[2])\n            // restore the dropped prefix\n            return type[2] + type[1][value];\n        return type[1][value];\n    }\n    message(type, value, fieldName, options) {\n        if (value === undefined)\n            return options.emitDefaultValues ? null : undefined;\n        return type.internalJsonWrite(value, options);\n    }\n    scalar(type, value, fieldName, optional, emitDefaultValues) {\n        if (value === undefined) {\n            assert(optional);\n            return undefined;\n        }\n        const ed = emitDefaultValues || optional;\n        // noinspection FallThroughInSwitchStatementJS\n        switch (type) {\n            // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n            case ScalarType.INT32:\n            case ScalarType.SFIXED32:\n            case ScalarType.SINT32:\n                if (value === 0)\n                    return ed ? 0 : undefined;\n                assertInt32(value);\n                return value;\n            case ScalarType.FIXED32:\n            case ScalarType.UINT32:\n                if (value === 0)\n                    return ed ? 0 : undefined;\n                assertUInt32(value);\n                return value;\n            // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n            // Either numbers or strings are accepted. Exponent notation is also accepted.\n            case ScalarType.FLOAT:\n                assertFloat32(value);\n            case ScalarType.DOUBLE:\n                if (value === 0)\n                    return ed ? 0 : undefined;\n                assert(typeof value == 'number');\n                if (Number.isNaN(value))\n                    return 'NaN';\n                if (value === Number.POSITIVE_INFINITY)\n                    return 'Infinity';\n                if (value === Number.NEGATIVE_INFINITY)\n                    return '-Infinity';\n                return value;\n            // string:\n            case ScalarType.STRING:\n                if (value === \"\")\n                    return ed ? '' : undefined;\n                assert(typeof value == 'string');\n                return value;\n            // bool:\n            case ScalarType.BOOL:\n                if (value === false)\n                    return ed ? false : undefined;\n                assert(typeof value == 'boolean');\n                return value;\n            // JSON value will be a decimal string. Either numbers or strings are accepted.\n            case ScalarType.UINT64:\n            case ScalarType.FIXED64:\n                assert(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');\n                let ulong = PbULong.from(value);\n                if (ulong.isZero() && !ed)\n                    return undefined;\n                return ulong.toString();\n            // JSON value will be a decimal string. Either numbers or strings are accepted.\n            case ScalarType.INT64:\n            case ScalarType.SFIXED64:\n            case ScalarType.SINT64:\n                assert(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');\n                let long = PbLong.from(value);\n                if (long.isZero() && !ed)\n                    return undefined;\n                return long.toString();\n            // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n            // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n            case ScalarType.BYTES:\n                assert(value instanceof Uint8Array);\n                if (!value.byteLength)\n                    return ed ? \"\" : undefined;\n                return base64encode(value);\n        }\n    }\n}\n","import { LongType, ScalarType } from \"./reflection-info\";\nimport { reflectionLongConvert } from \"./reflection-long-convert\";\nimport { PbLong, PbULong } from \"./pb-long\";\n/**\n * Creates the default value for a scalar type.\n */\nexport function reflectionScalarDefault(type, longType = LongType.STRING) {\n    switch (type) {\n        case ScalarType.BOOL:\n            return false;\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n            return reflectionLongConvert(PbULong.ZERO, longType);\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            return reflectionLongConvert(PbLong.ZERO, longType);\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            return 0.0;\n        case ScalarType.BYTES:\n            return new Uint8Array(0);\n        case ScalarType.STRING:\n            return \"\";\n        default:\n            // case ScalarType.INT32:\n            // case ScalarType.UINT32:\n            // case ScalarType.SINT32:\n            // case ScalarType.FIXED32:\n            // case ScalarType.SFIXED32:\n            return 0;\n    }\n}\n","import { UnknownFieldHandler, WireType } from \"./binary-format-contract\";\nimport { LongType, ScalarType } from \"./reflection-info\";\nimport { reflectionLongConvert } from \"./reflection-long-convert\";\nimport { reflectionScalarDefault } from \"./reflection-scalar-default\";\n/**\n * Reads proto3 messages in binary format using reflection information.\n *\n * https://developers.google.com/protocol-buffers/docs/encoding\n */\nexport class ReflectionBinaryReader {\n    constructor(info) {\n        this.info = info;\n    }\n    prepare() {\n        var _a;\n        if (!this.fieldNoToField) {\n            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];\n            this.fieldNoToField = new Map(fieldsInput.map(field => [field.no, field]));\n        }\n    }\n    /**\n     * Reads a message from binary format into the target message.\n     *\n     * Repeated fields are appended. Map entries are added, overwriting\n     * existing keys.\n     *\n     * If a message field is already present, it will be merged with the\n     * new data.\n     */\n    read(reader, message, options, length) {\n        this.prepare();\n        const end = length === undefined ? reader.len : reader.pos + length;\n        while (reader.pos < end) {\n            // read the tag and find the field\n            const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);\n            if (!field) {\n                let u = options.readUnknownField;\n                if (u == \"throw\")\n                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);\n                let d = reader.skip(wireType);\n                if (u !== false)\n                    (u === true ? UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);\n                continue;\n            }\n            // target object for the field we are reading\n            let target = message, repeated = field.repeat, localName = field.localName;\n            // if field is member of oneof ADT, use ADT as target\n            if (field.oneof) {\n                target = target[field.oneof];\n                // if other oneof member selected, set new ADT\n                if (target.oneofKind !== localName)\n                    target = message[field.oneof] = {\n                        oneofKind: localName\n                    };\n            }\n            // we have handled oneof above, we just have read the value into `target[localName]`\n            switch (field.kind) {\n                case \"scalar\":\n                case \"enum\":\n                    let T = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n                    let L = field.kind == \"scalar\" ? field.L : undefined;\n                    if (repeated) {\n                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n                        if (wireType == WireType.LengthDelimited && T != ScalarType.STRING && T != ScalarType.BYTES) {\n                            let e = reader.uint32() + reader.pos;\n                            while (reader.pos < e)\n                                arr.push(this.scalar(reader, T, L));\n                        }\n                        else\n                            arr.push(this.scalar(reader, T, L));\n                    }\n                    else\n                        target[localName] = this.scalar(reader, T, L);\n                    break;\n                case \"message\":\n                    if (repeated) {\n                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n                        let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);\n                        arr.push(msg);\n                    }\n                    else\n                        target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);\n                    break;\n                case \"map\":\n                    let [mapKey, mapVal] = this.mapEntry(field, reader, options);\n                    // safe to assume presence of map object, oneof cannot contain repeated values\n                    target[localName][mapKey] = mapVal;\n                    break;\n            }\n        }\n    }\n    /**\n     * Read a map field, expecting key field = 1, value field = 2\n     */\n    mapEntry(field, reader, options) {\n        let length = reader.uint32();\n        let end = reader.pos + length;\n        let key = undefined; // javascript only allows number or string for object properties\n        let val = undefined;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case 1:\n                    if (field.K == ScalarType.BOOL)\n                        key = reader.bool().toString();\n                    else\n                        // long types are read as string, number types are okay as number\n                        key = this.scalar(reader, field.K, LongType.STRING);\n                    break;\n                case 2:\n                    switch (field.V.kind) {\n                        case \"scalar\":\n                            val = this.scalar(reader, field.V.T, field.V.L);\n                            break;\n                        case \"enum\":\n                            val = reader.int32();\n                            break;\n                        case \"message\":\n                            val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);\n                            break;\n                    }\n                    break;\n                default:\n                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);\n            }\n        }\n        if (key === undefined) {\n            let keyRaw = reflectionScalarDefault(field.K);\n            key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;\n        }\n        if (val === undefined)\n            switch (field.V.kind) {\n                case \"scalar\":\n                    val = reflectionScalarDefault(field.V.T, field.V.L);\n                    break;\n                case \"enum\":\n                    val = 0;\n                    break;\n                case \"message\":\n                    val = field.V.T().create();\n                    break;\n            }\n        return [key, val];\n    }\n    scalar(reader, type, longType) {\n        switch (type) {\n            case ScalarType.INT32:\n                return reader.int32();\n            case ScalarType.STRING:\n                return reader.string();\n            case ScalarType.BOOL:\n                return reader.bool();\n            case ScalarType.DOUBLE:\n                return reader.double();\n            case ScalarType.FLOAT:\n                return reader.float();\n            case ScalarType.INT64:\n                return reflectionLongConvert(reader.int64(), longType);\n            case ScalarType.UINT64:\n                return reflectionLongConvert(reader.uint64(), longType);\n            case ScalarType.FIXED64:\n                return reflectionLongConvert(reader.fixed64(), longType);\n            case ScalarType.FIXED32:\n                return reader.fixed32();\n            case ScalarType.BYTES:\n                return reader.bytes();\n            case ScalarType.UINT32:\n                return reader.uint32();\n            case ScalarType.SFIXED32:\n                return reader.sfixed32();\n            case ScalarType.SFIXED64:\n                return reflectionLongConvert(reader.sfixed64(), longType);\n            case ScalarType.SINT32:\n                return reader.sint32();\n            case ScalarType.SINT64:\n                return reflectionLongConvert(reader.sint64(), longType);\n        }\n    }\n}\n","import { UnknownFieldHandler, WireType } from \"./binary-format-contract\";\nimport { RepeatType, ScalarType } from \"./reflection-info\";\nimport { assert } from \"./assert\";\nimport { PbLong, PbULong } from \"./pb-long\";\n/**\n * Writes proto3 messages in binary format using reflection information.\n *\n * https://developers.google.com/protocol-buffers/docs/encoding\n */\nexport class ReflectionBinaryWriter {\n    constructor(info) {\n        this.info = info;\n    }\n    prepare() {\n        if (!this.fields) {\n            const fieldsInput = this.info.fields ? this.info.fields.concat() : [];\n            this.fields = fieldsInput.sort((a, b) => a.no - b.no);\n        }\n    }\n    /**\n     * Writes the message to binary format.\n     */\n    write(message, writer, options) {\n        this.prepare();\n        for (const field of this.fields) {\n            let value, // this will be our field value, whether it is member of a oneof or not\n            emitDefault, // whether we emit the default value (only true for oneof members)\n            repeated = field.repeat, localName = field.localName;\n            // handle oneof ADT\n            if (field.oneof) {\n                const group = message[field.oneof];\n                if (group.oneofKind !== localName)\n                    continue; // if field is not selected, skip\n                value = group[localName];\n                emitDefault = true;\n            }\n            else {\n                value = message[localName];\n                emitDefault = false;\n            }\n            // we have handled oneof above. we just have to honor `emitDefault`.\n            switch (field.kind) {\n                case \"scalar\":\n                case \"enum\":\n                    let T = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n                    if (repeated) {\n                        assert(Array.isArray(value));\n                        if (repeated == RepeatType.PACKED)\n                            this.packed(writer, T, field.no, value);\n                        else\n                            for (const item of value)\n                                this.scalar(writer, T, field.no, item, true);\n                    }\n                    else if (value === undefined)\n                        assert(field.opt);\n                    else\n                        this.scalar(writer, T, field.no, value, emitDefault || field.opt);\n                    break;\n                case \"message\":\n                    if (repeated) {\n                        assert(Array.isArray(value));\n                        for (const item of value)\n                            this.message(writer, options, field.T(), field.no, item);\n                    }\n                    else {\n                        this.message(writer, options, field.T(), field.no, value);\n                    }\n                    break;\n                case \"map\":\n                    assert(typeof value == 'object' && value !== null);\n                    for (const [key, val] of Object.entries(value))\n                        this.mapEntry(writer, options, field, key, val);\n                    break;\n            }\n        }\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u === true ? UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);\n    }\n    mapEntry(writer, options, field, key, value) {\n        writer.tag(field.no, WireType.LengthDelimited);\n        writer.fork();\n        // javascript only allows number or string for object properties\n        // we convert from our representation to the protobuf type\n        let keyValue = key;\n        switch (field.K) {\n            case ScalarType.INT32:\n            case ScalarType.FIXED32:\n            case ScalarType.UINT32:\n            case ScalarType.SFIXED32:\n            case ScalarType.SINT32:\n                keyValue = Number.parseInt(key);\n                break;\n            case ScalarType.BOOL:\n                assert(key == 'true' || key == 'false');\n                keyValue = key == 'true';\n                break;\n        }\n        // write key, expecting key field number = 1\n        this.scalar(writer, field.K, 1, keyValue, true);\n        // write value, expecting value field number = 2\n        switch (field.V.kind) {\n            case 'scalar':\n                this.scalar(writer, field.V.T, 2, value, true);\n                break;\n            case 'enum':\n                this.scalar(writer, ScalarType.INT32, 2, value, true);\n                break;\n            case 'message':\n                this.message(writer, options, field.V.T(), 2, value);\n                break;\n        }\n        writer.join();\n    }\n    message(writer, options, handler, fieldNo, value) {\n        if (value === undefined)\n            return;\n        handler.internalBinaryWrite(value, writer.tag(fieldNo, WireType.LengthDelimited).fork(), options);\n        writer.join();\n    }\n    /**\n     * Write a single scalar value.\n     */\n    scalar(writer, type, fieldNo, value, emitDefault) {\n        let [wireType, method, isDefault] = this.scalarInfo(type, value);\n        if (!isDefault || emitDefault) {\n            writer.tag(fieldNo, wireType);\n            writer[method](value);\n        }\n    }\n    /**\n     * Write an array of scalar values in packed format.\n     */\n    packed(writer, type, fieldNo, value) {\n        if (!value.length)\n            return;\n        assert(type !== ScalarType.BYTES && type !== ScalarType.STRING);\n        // write tag\n        writer.tag(fieldNo, WireType.LengthDelimited);\n        // begin length-delimited\n        writer.fork();\n        // write values without tags\n        let [, method,] = this.scalarInfo(type);\n        for (let i = 0; i < value.length; i++)\n            writer[method](value[i]);\n        // end length delimited\n        writer.join();\n    }\n    /**\n     * Get information for writing a scalar value.\n     *\n     * Returns tuple:\n     * [0]: appropriate WireType\n     * [1]: name of the appropriate method of IBinaryWriter\n     * [2]: whether the given value is a default value\n     *\n     * If argument `value` is omitted, [2] is always false.\n     */\n    scalarInfo(type, value) {\n        let t = WireType.Varint;\n        let m;\n        let i = value === undefined;\n        let d = value === 0;\n        switch (type) {\n            case ScalarType.INT32:\n                m = \"int32\";\n                break;\n            case ScalarType.STRING:\n                d = i || !value.length;\n                t = WireType.LengthDelimited;\n                m = \"string\";\n                break;\n            case ScalarType.BOOL:\n                d = value === false;\n                m = \"bool\";\n                break;\n            case ScalarType.UINT32:\n                m = \"uint32\";\n                break;\n            case ScalarType.DOUBLE:\n                t = WireType.Bit64;\n                m = \"double\";\n                break;\n            case ScalarType.FLOAT:\n                t = WireType.Bit32;\n                m = \"float\";\n                break;\n            case ScalarType.INT64:\n                d = i || PbLong.from(value).isZero();\n                m = \"int64\";\n                break;\n            case ScalarType.UINT64:\n                d = i || PbULong.from(value).isZero();\n                m = \"uint64\";\n                break;\n            case ScalarType.FIXED64:\n                d = i || PbULong.from(value).isZero();\n                t = WireType.Bit64;\n                m = \"fixed64\";\n                break;\n            case ScalarType.BYTES:\n                d = i || !value.byteLength;\n                t = WireType.LengthDelimited;\n                m = \"bytes\";\n                break;\n            case ScalarType.FIXED32:\n                t = WireType.Bit32;\n                m = \"fixed32\";\n                break;\n            case ScalarType.SFIXED32:\n                t = WireType.Bit32;\n                m = \"sfixed32\";\n                break;\n            case ScalarType.SFIXED64:\n                d = i || PbLong.from(value).isZero();\n                t = WireType.Bit64;\n                m = \"sfixed64\";\n                break;\n            case ScalarType.SINT32:\n                m = \"sint32\";\n                break;\n            case ScalarType.SINT64:\n                d = i || PbLong.from(value).isZero();\n                m = \"sint64\";\n                break;\n        }\n        return [t, m, i || d];\n    }\n}\n","import { reflectionScalarDefault } from \"./reflection-scalar-default\";\nimport { MESSAGE_TYPE } from './message-type-contract';\n/**\n * Creates an instance of the generic message, using the field\n * information.\n */\nexport function reflectionCreate(type) {\n    const msg = {};\n    Object.defineProperty(msg, MESSAGE_TYPE, { enumerable: false, value: type });\n    for (let field of type.fields) {\n        let name = field.localName;\n        if (field.opt)\n            continue;\n        if (field.oneof)\n            msg[field.oneof] = { oneofKind: undefined };\n        else if (field.repeat)\n            msg[name] = [];\n        else\n            switch (field.kind) {\n                case \"scalar\":\n                    msg[name] = reflectionScalarDefault(field.T, field.L);\n                    break;\n                case \"enum\":\n                    // we require 0 to be default value for all enums\n                    msg[name] = 0;\n                    break;\n                case \"map\":\n                    msg[name] = {};\n                    break;\n            }\n    }\n    return msg;\n}\n","/**\n * Copy partial data into the target message.\n *\n * If a singular scalar or enum field is present in the source, it\n * replaces the field in the target.\n *\n * If a singular message field is present in the source, it is merged\n * with the target field by calling mergePartial() of the responsible\n * message type.\n *\n * If a repeated field is present in the source, its values replace\n * all values in the target array, removing extraneous values.\n * Repeated message fields are copied, not merged.\n *\n * If a map field is present in the source, entries are added to the\n * target map, replacing entries with the same key. Entries that only\n * exist in the target remain. Entries with message values are copied,\n * not merged.\n *\n * Note that this function differs from protobuf merge semantics,\n * which appends repeated fields.\n */\nexport function reflectionMergePartial(info, target, source) {\n    let fieldValue, // the field value we are working with\n    input = source, output; // where we want our field value to go\n    for (let field of info.fields) {\n        let name = field.localName;\n        if (field.oneof) {\n            const group = input[field.oneof]; // this is the oneof`s group in the source\n            if ((group === null || group === void 0 ? void 0 : group.oneofKind) == undefined) { // the user is free to omit\n                continue; // we skip this field, and all other members too\n            }\n            fieldValue = group[name]; // our value comes from the the oneof group of the source\n            output = target[field.oneof]; // and our output is the oneof group of the target\n            output.oneofKind = group.oneofKind; // always update discriminator\n            if (fieldValue == undefined) {\n                delete output[name]; // remove any existing value\n                continue; // skip further work on field\n            }\n        }\n        else {\n            fieldValue = input[name]; // we are using the source directly\n            output = target; // we want our field value to go directly into the target\n            if (fieldValue == undefined) {\n                continue; // skip further work on field, existing value is used as is\n            }\n        }\n        if (field.repeat)\n            output[name].length = fieldValue.length; // resize target array to match source array\n        // now we just work with `fieldValue` and `output` to merge the value\n        switch (field.kind) {\n            case \"scalar\":\n            case \"enum\":\n                if (field.repeat)\n                    for (let i = 0; i < fieldValue.length; i++)\n                        output[name][i] = fieldValue[i]; // not a reference type\n                else\n                    output[name] = fieldValue; // not a reference type\n                break;\n            case \"message\":\n                let T = field.T();\n                if (field.repeat)\n                    for (let i = 0; i < fieldValue.length; i++)\n                        output[name][i] = T.create(fieldValue[i]);\n                else if (output[name] === undefined)\n                    output[name] = T.create(fieldValue); // nothing to merge with\n                else\n                    T.mergePartial(output[name], fieldValue);\n                break;\n            case \"map\":\n                // Map and repeated fields are simply overwritten, not appended or merged\n                switch (field.V.kind) {\n                    case \"scalar\":\n                    case \"enum\":\n                        Object.assign(output[name], fieldValue); // elements are not reference types\n                        break;\n                    case \"message\":\n                        let T = field.V.T();\n                        for (let k of Object.keys(fieldValue))\n                            output[name][k] = T.create(fieldValue[k]);\n                        break;\n                }\n                break;\n        }\n    }\n}\n","import { ScalarType } from \"./reflection-info\";\n/**\n * Determines whether two message of the same type have the same field values.\n * Checks for deep equality, traversing repeated fields, oneof groups, maps\n * and messages recursively.\n * Will also return true if both messages are `undefined`.\n */\nexport function reflectionEquals(info, a, b) {\n    if (a === b)\n        return true;\n    if (!a || !b)\n        return false;\n    for (let field of info.fields) {\n        let localName = field.localName;\n        let val_a = field.oneof ? a[field.oneof][localName] : a[localName];\n        let val_b = field.oneof ? b[field.oneof][localName] : b[localName];\n        switch (field.kind) {\n            case \"enum\":\n            case \"scalar\":\n                let t = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n                if (!(field.repeat\n                    ? repeatedPrimitiveEq(t, val_a, val_b)\n                    : primitiveEq(t, val_a, val_b)))\n                    return false;\n                break;\n            case \"map\":\n                if (!(field.V.kind == \"message\"\n                    ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b))\n                    : repeatedPrimitiveEq(field.V.kind == \"enum\" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))\n                    return false;\n                break;\n            case \"message\":\n                let T = field.T();\n                if (!(field.repeat\n                    ? repeatedMsgEq(T, val_a, val_b)\n                    : T.equals(val_a, val_b)))\n                    return false;\n                break;\n        }\n    }\n    return true;\n}\nconst objectValues = Object.values;\nfunction primitiveEq(type, a, b) {\n    if (a === b)\n        return true;\n    if (type !== ScalarType.BYTES)\n        return false;\n    let ba = a;\n    let bb = b;\n    if (ba.length !== bb.length)\n        return false;\n    for (let i = 0; i < ba.length; i++)\n        if (ba[i] != bb[i])\n            return false;\n    return true;\n}\nfunction repeatedPrimitiveEq(type, a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!primitiveEq(type, a[i], b[i]))\n            return false;\n    return true;\n}\nfunction repeatedMsgEq(type, a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!type.equals(a[i], b[i]))\n            return false;\n    return true;\n}\n","import { normalizeFieldInfo } from \"./reflection-info\";\nimport { ReflectionTypeCheck } from \"./reflection-type-check\";\nimport { ReflectionJsonReader } from \"./reflection-json-reader\";\nimport { ReflectionJsonWriter } from \"./reflection-json-writer\";\nimport { ReflectionBinaryReader } from \"./reflection-binary-reader\";\nimport { ReflectionBinaryWriter } from \"./reflection-binary-writer\";\nimport { reflectionCreate } from \"./reflection-create\";\nimport { reflectionMergePartial } from \"./reflection-merge-partial\";\nimport { typeofJsonValue } from \"./json-typings\";\nimport { jsonReadOptions, jsonWriteOptions, } from \"./json-format-contract\";\nimport { reflectionEquals } from \"./reflection-equals\";\nimport { binaryWriteOptions } from \"./binary-writer\";\nimport { binaryReadOptions } from \"./binary-reader\";\n/**\n * This standard message type provides reflection-based\n * operations to work with a message.\n */\nexport class MessageType {\n    constructor(name, fields, options) {\n        this.defaultCheckDepth = 16;\n        this.typeName = name;\n        this.fields = fields.map(normalizeFieldInfo);\n        this.options = options !== null && options !== void 0 ? options : {};\n        this.refTypeCheck = new ReflectionTypeCheck(this);\n        this.refJsonReader = new ReflectionJsonReader(this);\n        this.refJsonWriter = new ReflectionJsonWriter(this);\n        this.refBinReader = new ReflectionBinaryReader(this);\n        this.refBinWriter = new ReflectionBinaryWriter(this);\n    }\n    create(value) {\n        let message = reflectionCreate(this);\n        if (value !== undefined) {\n            reflectionMergePartial(this, message, value);\n        }\n        return message;\n    }\n    /**\n     * Clone the message.\n     *\n     * Unknown fields are discarded.\n     */\n    clone(message) {\n        let copy = this.create();\n        reflectionMergePartial(this, copy, message);\n        return copy;\n    }\n    /**\n     * Determines whether two message of the same type have the same field values.\n     * Checks for deep equality, traversing repeated fields, oneof groups, maps\n     * and messages recursively.\n     * Will also return true if both messages are `undefined`.\n     */\n    equals(a, b) {\n        return reflectionEquals(this, a, b);\n    }\n    /**\n     * Is the given value assignable to our message type\n     * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?\n     */\n    is(arg, depth = this.defaultCheckDepth) {\n        return this.refTypeCheck.is(arg, depth, false);\n    }\n    /**\n     * Is the given value assignable to our message type,\n     * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?\n     */\n    isAssignable(arg, depth = this.defaultCheckDepth) {\n        return this.refTypeCheck.is(arg, depth, true);\n    }\n    /**\n     * Copy partial data into the target message.\n     */\n    mergePartial(target, source) {\n        reflectionMergePartial(this, target, source);\n    }\n    /**\n     * Create a new message from binary format.\n     */\n    fromBinary(data, options) {\n        let opt = binaryReadOptions(options);\n        return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);\n    }\n    /**\n     * Read a new message from a JSON value.\n     */\n    fromJson(json, options) {\n        return this.internalJsonRead(json, jsonReadOptions(options));\n    }\n    /**\n     * Read a new message from a JSON string.\n     * This is equivalent to `T.fromJson(JSON.parse(json))`.\n     */\n    fromJsonString(json, options) {\n        let value = JSON.parse(json);\n        return this.fromJson(value, options);\n    }\n    /**\n     * Write the message to canonical JSON value.\n     */\n    toJson(message, options) {\n        return this.internalJsonWrite(message, jsonWriteOptions(options));\n    }\n    /**\n     * Convert the message to canonical JSON string.\n     * This is equivalent to `JSON.stringify(T.toJson(t))`\n     */\n    toJsonString(message, options) {\n        var _a;\n        let value = this.toJson(message, options);\n        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\n    }\n    /**\n     * Write the message to binary format.\n     */\n    toBinary(message, options) {\n        let opt = binaryWriteOptions(options);\n        return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();\n    }\n    /**\n     * This is an internal method. If you just want to read a message from\n     * JSON, use `fromJson()` or `fromJsonString()`.\n     *\n     * Reads JSON value and merges the fields into the target\n     * according to protobuf rules. If the target is omitted,\n     * a new instance is created first.\n     */\n    internalJsonRead(json, options, target) {\n        if (json !== null && typeof json == \"object\" && !Array.isArray(json)) {\n            let message = target !== null && target !== void 0 ? target : this.create();\n            this.refJsonReader.read(json, message, options);\n            return message;\n        }\n        throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`);\n    }\n    /**\n     * This is an internal method. If you just want to write a message\n     * to JSON, use `toJson()` or `toJsonString().\n     *\n     * Writes JSON value and returns it.\n     */\n    internalJsonWrite(message, options) {\n        return this.refJsonWriter.write(message, options);\n    }\n    /**\n     * This is an internal method. If you just want to write a message\n     * in binary format, use `toBinary()`.\n     *\n     * Serializes the message in binary format and appends it to the given\n     * writer. Returns passed writer.\n     */\n    internalBinaryWrite(message, writer, options) {\n        this.refBinWriter.write(message, writer, options);\n        return writer;\n    }\n    /**\n     * This is an internal method. If you just want to read a message from\n     * binary data, use `fromBinary()`.\n     *\n     * Reads data from binary format and merges the fields into\n     * the target according to protobuf rules. If the target is\n     * omitted, a new instance is created first.\n     */\n    internalBinaryRead(reader, length, options, target) {\n        let message = target !== null && target !== void 0 ? target : this.create();\n        this.refBinReader.read(reader, message, options, length);\n        return message;\n    }\n}\n","// @generated by protobuf-ts 2.9.0 with parameter optimize_code_size\n// @generated from protobuf file \"google/protobuf/timestamp.proto\" (package \"google.protobuf\", syntax proto3)\n// tslint:disable\n//\n// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\nimport { typeofJsonValue } from \"@protobuf-ts/runtime\";\nimport type { JsonValue } from \"@protobuf-ts/runtime\";\nimport type { JsonReadOptions } from \"@protobuf-ts/runtime\";\nimport type { JsonWriteOptions } from \"@protobuf-ts/runtime\";\nimport { PbLong } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D\n * ) to obtain a formatter capable of generating timestamps in this format.\n *\n *\n *\n * @generated from protobuf message google.protobuf.Timestamp\n */\nexport interface Timestamp {\n    /**\n     * Represents seconds of UTC time since Unix epoch\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     * 9999-12-31T23:59:59Z inclusive.\n     *\n     * @generated from protobuf field: int64 seconds = 1;\n     */\n    seconds: bigint;\n    /**\n     * Non-negative fractions of a second at nanosecond resolution. Negative\n     * second values with fractions must still have non-negative nanos values\n     * that count forward in time. Must be from 0 to 999,999,999\n     * inclusive.\n     *\n     * @generated from protobuf field: int32 nanos = 2;\n     */\n    nanos: number;\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass Timestamp$Type extends MessageType<Timestamp> {\n    constructor() {\n        super(\"google.protobuf.Timestamp\", [\n            { no: 1, name: \"seconds\", kind: \"scalar\", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"nanos\", kind: \"scalar\", T: 5 /*ScalarType.INT32*/ }\n        ]);\n    }\n    /**\n     * Creates a new `Timestamp` for the current time.\n     */\n    now(): Timestamp {\n        const msg = this.create();\n        const ms = Date.now();\n        msg.seconds = PbLong.from(Math.floor(ms / 1000)).toBigInt();\n        msg.nanos = (ms % 1000) * 1000000;\n        return msg;\n    }\n    /**\n     * Converts a `Timestamp` to a JavaScript Date.\n     */\n    toDate(message: Timestamp): Date {\n        return new Date(PbLong.from(message.seconds).toNumber() * 1000 + Math.ceil(message.nanos / 1000000));\n    }\n    /**\n     * Converts a JavaScript Date to a `Timestamp`.\n     */\n    fromDate(date: Date): Timestamp {\n        const msg = this.create();\n        const ms = date.getTime();\n        msg.seconds = PbLong.from(Math.floor(ms / 1000)).toBigInt();\n        msg.nanos = (ms % 1000) * 1000000;\n        return msg;\n    }\n    /**\n     * In JSON format, the `Timestamp` type is encoded as a string\n     * in the RFC 3339 format.\n     */\n    internalJsonWrite(message: Timestamp, options: JsonWriteOptions): JsonValue {\n        let ms = PbLong.from(message.seconds).toNumber() * 1000;\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\"))\n            throw new Error(\"Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.\");\n        if (message.nanos < 0)\n            throw new Error(\"Unable to encode invalid Timestamp to JSON. Nanos must not be negative.\");\n        let z = \"Z\";\n        if (message.nanos > 0) {\n            let nanosStr = (message.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === \"000000\")\n                z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n            else if (nanosStr.substring(6) === \"000\")\n                z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n            else\n                z = \".\" + nanosStr + \"Z\";\n        }\n        return new Date(ms).toISOString().replace(\".000Z\", z);\n    }\n    /**\n     * In JSON format, the `Timestamp` type is encoded as a string\n     * in the RFC 3339 format.\n     */\n    internalJsonRead(json: JsonValue, options: JsonReadOptions, target?: Timestamp): Timestamp {\n        if (typeof json !== \"string\")\n            throw new Error(\"Unable to parse Timestamp from JSON \" + typeofJsonValue(json) + \".\");\n        let matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches)\n            throw new Error(\"Unable to parse Timestamp from JSON. Invalid format.\");\n        let ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n        if (Number.isNaN(ms))\n            throw new Error(\"Unable to parse Timestamp from JSON. Invalid value.\");\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\"))\n            throw new globalThis.Error(\"Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.\");\n        if (!target)\n            target = this.create();\n        target.seconds = PbLong.from(ms / 1000).toBigInt();\n        target.nanos = 0;\n        if (matches[7])\n            target.nanos = (parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000);\n        return target;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Timestamp\n */\nexport const Timestamp = new Timestamp$Type();\n","// @generated by protobuf-ts 2.9.0 with parameter optimize_code_size\n// @generated from protobuf file \"Flight.proto\" (package \"arrow.flight.protocol\", syntax proto3)\n// tslint:disable\n//\n//\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n// <p>\n// http://www.apache.org/licenses/LICENSE-2.0\n// <p>\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\nimport type { RpcTransport } from \"@protobuf-ts/runtime-rpc\";\nimport type { ServiceInfo } from \"@protobuf-ts/runtime-rpc\";\nimport { FlightService } from \"./Flight\";\nimport type { ActionType } from \"./Flight\";\nimport type { Empty } from \"./Flight\";\nimport type { Result } from \"./Flight\";\nimport type { Action } from \"./Flight\";\nimport type { PutResult } from \"./Flight\";\nimport type { FlightData } from \"./Flight\";\nimport type { Ticket } from \"./Flight\";\nimport type { SchemaResult } from \"./Flight\";\nimport type { FlightDescriptor } from \"./Flight\";\nimport type { UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { FlightInfo } from \"./Flight\";\nimport type { Criteria } from \"./Flight\";\nimport type { ServerStreamingCall } from \"@protobuf-ts/runtime-rpc\";\nimport { stackIntercept } from \"@protobuf-ts/runtime-rpc\";\nimport type { HandshakeResponse } from \"./Flight\";\nimport type { HandshakeRequest } from \"./Flight\";\nimport type { DuplexStreamingCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n/**\n *\n * A flight service is an endpoint for retrieving or storing Arrow data. A\n * flight service can expose one or more predefined endpoints that can be\n * accessed using the Arrow Flight Protocol. Additionally, a flight service\n * can expose a set of actions that are available.\n *\n * @generated from protobuf service arrow.flight.protocol.FlightService\n */\nexport interface IFlightServiceClient {\n    /**\n     *\n     * Handshake between client and server. Depending on the server, the\n     * handshake may be required to determine the token that should be used for\n     * future operations. Both request and response are streams to allow multiple\n     * round-trips depending on auth mechanism.\n     *\n     * @generated from protobuf rpc: Handshake(stream arrow.flight.protocol.HandshakeRequest) returns (stream arrow.flight.protocol.HandshakeResponse);\n     */\n    handshake(options?: RpcOptions): DuplexStreamingCall<HandshakeRequest, HandshakeResponse>;\n    /**\n     *\n     * Get a list of available streams given a particular criteria. Most flight\n     * services will expose one or more streams that are readily available for\n     * retrieval. This api allows listing the streams available for\n     * consumption. A user can also provide a criteria. The criteria can limit\n     * the subset of streams that can be listed via this interface. Each flight\n     * service allows its own definition of how to consume criteria.\n     *\n     * @generated from protobuf rpc: ListFlights(arrow.flight.protocol.Criteria) returns (stream arrow.flight.protocol.FlightInfo);\n     */\n    listFlights(input: Criteria, options?: RpcOptions): ServerStreamingCall<Criteria, FlightInfo>;\n    /**\n     *\n     * For a given FlightDescriptor, get information about how the flight can be\n     * consumed. This is a useful interface if the consumer of the interface\n     * already can identify the specific flight to consume. This interface can\n     * also allow a consumer to generate a flight stream through a specified\n     * descriptor. For example, a flight descriptor might be something that\n     * includes a SQL statement or a Pickled Python operation that will be\n     * executed. In those cases, the descriptor will not be previously available\n     * within the list of available streams provided by ListFlights but will be\n     * available for consumption for the duration defined by the specific flight\n     * service.\n     *\n     * @generated from protobuf rpc: GetFlightInfo(arrow.flight.protocol.FlightDescriptor) returns (arrow.flight.protocol.FlightInfo);\n     */\n    getFlightInfo(input: FlightDescriptor, options?: RpcOptions): UnaryCall<FlightDescriptor, FlightInfo>;\n    /**\n     *\n     * For a given FlightDescriptor, get the Schema as described in Schema.fbs::Schema\n     * This is used when a consumer needs the Schema of flight stream. Similar to\n     * GetFlightInfo this interface may generate a new flight that was not previously\n     * available in ListFlights.\n     *\n     * @generated from protobuf rpc: GetSchema(arrow.flight.protocol.FlightDescriptor) returns (arrow.flight.protocol.SchemaResult);\n     */\n    getSchema(input: FlightDescriptor, options?: RpcOptions): UnaryCall<FlightDescriptor, SchemaResult>;\n    /**\n     *\n     * Retrieve a single stream associated with a particular descriptor\n     * associated with the referenced ticket. A Flight can be composed of one or\n     * more streams where each stream can be retrieved using a separate opaque\n     * ticket that the flight service uses for managing a collection of streams.\n     *\n     * @generated from protobuf rpc: DoGet(arrow.flight.protocol.Ticket) returns (stream arrow.flight.protocol.FlightData);\n     */\n    doGet(input: Ticket, options?: RpcOptions): ServerStreamingCall<Ticket, FlightData>;\n    /**\n     *\n     * Push a stream to the flight service associated with a particular\n     * flight stream. This allows a client of a flight service to upload a stream\n     * of data. Depending on the particular flight service, a client consumer\n     * could be allowed to upload a single stream per descriptor or an unlimited\n     * number. In the latter, the service might implement a 'seal' action that\n     * can be applied to a descriptor once all streams are uploaded.\n     *\n     * @generated from protobuf rpc: DoPut(stream arrow.flight.protocol.FlightData) returns (stream arrow.flight.protocol.PutResult);\n     */\n    doPut(options?: RpcOptions): DuplexStreamingCall<FlightData, PutResult>;\n    /**\n     *\n     * Open a bidirectional data channel for a given descriptor. This\n     * allows clients to send and receive arbitrary Arrow data and\n     * application-specific metadata in a single logical stream. In\n     * contrast to DoGet/DoPut, this is more suited for clients\n     * offloading computation (rather than storage) to a Flight service.\n     *\n     * @generated from protobuf rpc: DoExchange(stream arrow.flight.protocol.FlightData) returns (stream arrow.flight.protocol.FlightData);\n     */\n    doExchange(options?: RpcOptions): DuplexStreamingCall<FlightData, FlightData>;\n    /**\n     *\n     * Flight services can support an arbitrary number of simple actions in\n     * addition to the possible ListFlights, GetFlightInfo, DoGet, DoPut\n     * operations that are potentially available. DoAction allows a flight client\n     * to do a specific action against a flight service. An action includes\n     * opaque request and response objects that are specific to the type action\n     * being undertaken.\n     *\n     * @generated from protobuf rpc: DoAction(arrow.flight.protocol.Action) returns (stream arrow.flight.protocol.Result);\n     */\n    doAction(input: Action, options?: RpcOptions): ServerStreamingCall<Action, Result>;\n    /**\n     *\n     * A flight service exposes all of the available action types that it has\n     * along with descriptions. This allows different flight consumers to\n     * understand the capabilities of the flight service.\n     *\n     * @generated from protobuf rpc: ListActions(arrow.flight.protocol.Empty) returns (stream arrow.flight.protocol.ActionType);\n     */\n    listActions(input: Empty, options?: RpcOptions): ServerStreamingCall<Empty, ActionType>;\n}\n/**\n *\n * A flight service is an endpoint for retrieving or storing Arrow data. A\n * flight service can expose one or more predefined endpoints that can be\n * accessed using the Arrow Flight Protocol. Additionally, a flight service\n * can expose a set of actions that are available.\n *\n * @generated from protobuf service arrow.flight.protocol.FlightService\n */\nexport class FlightServiceClient implements IFlightServiceClient, ServiceInfo {\n    typeName = FlightService.typeName;\n    methods = FlightService.methods;\n    options = FlightService.options;\n    constructor(private readonly _transport: RpcTransport) {\n    }\n    /**\n     *\n     * Handshake between client and server. Depending on the server, the\n     * handshake may be required to determine the token that should be used for\n     * future operations. Both request and response are streams to allow multiple\n     * round-trips depending on auth mechanism.\n     *\n     * @generated from protobuf rpc: Handshake(stream arrow.flight.protocol.HandshakeRequest) returns (stream arrow.flight.protocol.HandshakeResponse);\n     */\n    handshake(options?: RpcOptions): DuplexStreamingCall<HandshakeRequest, HandshakeResponse> {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return stackIntercept<HandshakeRequest, HandshakeResponse>(\"duplex\", this._transport, method, opt);\n    }\n    /**\n     *\n     * Get a list of available streams given a particular criteria. Most flight\n     * services will expose one or more streams that are readily available for\n     * retrieval. This api allows listing the streams available for\n     * consumption. A user can also provide a criteria. The criteria can limit\n     * the subset of streams that can be listed via this interface. Each flight\n     * service allows its own definition of how to consume criteria.\n     *\n     * @generated from protobuf rpc: ListFlights(arrow.flight.protocol.Criteria) returns (stream arrow.flight.protocol.FlightInfo);\n     */\n    listFlights(input: Criteria, options?: RpcOptions): ServerStreamingCall<Criteria, FlightInfo> {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return stackIntercept<Criteria, FlightInfo>(\"serverStreaming\", this._transport, method, opt, input);\n    }\n    /**\n     *\n     * For a given FlightDescriptor, get information about how the flight can be\n     * consumed. This is a useful interface if the consumer of the interface\n     * already can identify the specific flight to consume. This interface can\n     * also allow a consumer to generate a flight stream through a specified\n     * descriptor. For example, a flight descriptor might be something that\n     * includes a SQL statement or a Pickled Python operation that will be\n     * executed. In those cases, the descriptor will not be previously available\n     * within the list of available streams provided by ListFlights but will be\n     * available for consumption for the duration defined by the specific flight\n     * service.\n     *\n     * @generated from protobuf rpc: GetFlightInfo(arrow.flight.protocol.FlightDescriptor) returns (arrow.flight.protocol.FlightInfo);\n     */\n    getFlightInfo(input: FlightDescriptor, options?: RpcOptions): UnaryCall<FlightDescriptor, FlightInfo> {\n        const method = this.methods[2], opt = this._transport.mergeOptions(options);\n        return stackIntercept<FlightDescriptor, FlightInfo>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     *\n     * For a given FlightDescriptor, get the Schema as described in Schema.fbs::Schema\n     * This is used when a consumer needs the Schema of flight stream. Similar to\n     * GetFlightInfo this interface may generate a new flight that was not previously\n     * available in ListFlights.\n     *\n     * @generated from protobuf rpc: GetSchema(arrow.flight.protocol.FlightDescriptor) returns (arrow.flight.protocol.SchemaResult);\n     */\n    getSchema(input: FlightDescriptor, options?: RpcOptions): UnaryCall<FlightDescriptor, SchemaResult> {\n        const method = this.methods[3], opt = this._transport.mergeOptions(options);\n        return stackIntercept<FlightDescriptor, SchemaResult>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     *\n     * Retrieve a single stream associated with a particular descriptor\n     * associated with the referenced ticket. A Flight can be composed of one or\n     * more streams where each stream can be retrieved using a separate opaque\n     * ticket that the flight service uses for managing a collection of streams.\n     *\n     * @generated from protobuf rpc: DoGet(arrow.flight.protocol.Ticket) returns (stream arrow.flight.protocol.FlightData);\n     */\n    doGet(input: Ticket, options?: RpcOptions): ServerStreamingCall<Ticket, FlightData> {\n        const method = this.methods[4], opt = this._transport.mergeOptions(options);\n        return stackIntercept<Ticket, FlightData>(\"serverStreaming\", this._transport, method, opt, input);\n    }\n    /**\n     *\n     * Push a stream to the flight service associated with a particular\n     * flight stream. This allows a client of a flight service to upload a stream\n     * of data. Depending on the particular flight service, a client consumer\n     * could be allowed to upload a single stream per descriptor or an unlimited\n     * number. In the latter, the service might implement a 'seal' action that\n     * can be applied to a descriptor once all streams are uploaded.\n     *\n     * @generated from protobuf rpc: DoPut(stream arrow.flight.protocol.FlightData) returns (stream arrow.flight.protocol.PutResult);\n     */\n    doPut(options?: RpcOptions): DuplexStreamingCall<FlightData, PutResult> {\n        const method = this.methods[5], opt = this._transport.mergeOptions(options);\n        return stackIntercept<FlightData, PutResult>(\"duplex\", this._transport, method, opt);\n    }\n    /**\n     *\n     * Open a bidirectional data channel for a given descriptor. This\n     * allows clients to send and receive arbitrary Arrow data and\n     * application-specific metadata in a single logical stream. In\n     * contrast to DoGet/DoPut, this is more suited for clients\n     * offloading computation (rather than storage) to a Flight service.\n     *\n     * @generated from protobuf rpc: DoExchange(stream arrow.flight.protocol.FlightData) returns (stream arrow.flight.protocol.FlightData);\n     */\n    doExchange(options?: RpcOptions): DuplexStreamingCall<FlightData, FlightData> {\n        const method = this.methods[6], opt = this._transport.mergeOptions(options);\n        return stackIntercept<FlightData, FlightData>(\"duplex\", this._transport, method, opt);\n    }\n    /**\n     *\n     * Flight services can support an arbitrary number of simple actions in\n     * addition to the possible ListFlights, GetFlightInfo, DoGet, DoPut\n     * operations that are potentially available. DoAction allows a flight client\n     * to do a specific action against a flight service. An action includes\n     * opaque request and response objects that are specific to the type action\n     * being undertaken.\n     *\n     * @generated from protobuf rpc: DoAction(arrow.flight.protocol.Action) returns (stream arrow.flight.protocol.Result);\n     */\n    doAction(input: Action, options?: RpcOptions): ServerStreamingCall<Action, Result> {\n        const method = this.methods[7], opt = this._transport.mergeOptions(options);\n        return stackIntercept<Action, Result>(\"serverStreaming\", this._transport, method, opt, input);\n    }\n    /**\n     *\n     * A flight service exposes all of the available action types that it has\n     * along with descriptions. This allows different flight consumers to\n     * understand the capabilities of the flight service.\n     *\n     * @generated from protobuf rpc: ListActions(arrow.flight.protocol.Empty) returns (stream arrow.flight.protocol.ActionType);\n     */\n    listActions(input: Empty, options?: RpcOptions): ServerStreamingCall<Empty, ActionType> {\n        const method = this.methods[8], opt = this._transport.mergeOptions(options);\n        return stackIntercept<Empty, ActionType>(\"serverStreaming\", this._transport, method, opt, input);\n    }\n}\n","import WriteApi from './WriteApi'\nimport WriteApiImpl from './impl/WriteApiImpl'\nimport QueryApi from './QueryApi'\nimport QueryApiImpl from './impl/QueryApiImpl'\nimport {ClientOptions, QueryType, WriteOptions} from './options'\nimport {IllegalArgumentError} from './errors'\nimport {WritableData, writableDataToLineProtocol} from './util/generics'\nimport {throwReturn} from './util/common'\nimport {PointValues} from './PointValues'\n\nconst argumentErrorMessage = `\\\nPlease specify the 'database' as a method parameter or use default configuration \\\nat 'ClientOptions.database'\n`\n\n/**\n * `InfluxDBClient` for interacting with an InfluxDB server, simplifying common operations such as writing, querying.\n */\nexport default class InfluxDBClient {\n  private readonly _options: ClientOptions\n  private readonly _writeApi: WriteApi\n  private readonly _queryApi: QueryApi\n\n  /**\n   * Creates a new instance of the `InfluxDBClient` for interacting with an InfluxDB server, simplifying common operations such as writing, querying.\n   * @param options - client options\n   */\n  constructor(options: ClientOptions) {\n    if (options === undefined || options === null)\n      throw new IllegalArgumentError('No configuration specified!')\n    this._options = options\n    const host = this._options.host\n    if (typeof host !== 'string')\n      throw new IllegalArgumentError('No host specified!')\n    if (host.endsWith('/'))\n      this._options.host = host.substring(0, host.length - 1)\n    this._queryApi = new QueryApiImpl(this._options)\n    this._writeApi = new WriteApiImpl(this._options)\n  }\n\n  private _mergeWriteOptions = (writeOptions?: Partial<WriteOptions>) => {\n    return {\n      ...this._options.writeOptions,\n      ...writeOptions,\n    }\n  }\n\n  /**\n   * Write data into specified database.\n   * @param data - data to write\n   * @param database - database to write into\n   * @param org - organization to write into\n   * @param writeOptions - write options\n   */\n  async write(\n    data: WritableData,\n    database?: string,\n    org?: string,\n    writeOptions?: Partial<WriteOptions>\n  ): Promise<void> {\n    await this._writeApi.doWrite(\n      writableDataToLineProtocol(data),\n      database ??\n        this._options.database ??\n        throwReturn(new Error(argumentErrorMessage)),\n      org,\n      this._mergeWriteOptions(writeOptions)\n    )\n  }\n\n  /**\n   * Execute a query and return the results as an async generator.\n   *\n   * @param query - The query string.\n   * @param database - The name of the database to query.\n   * @param queryType - The type of query (default: 'sql').\n   * @returns An async generator that yields maps of string keys to any values.\n   */\n  query(\n    query: string,\n    database?: string,\n    queryType: QueryType = 'sql'\n  ): AsyncGenerator<Record<string, any>, void, void> {\n    return this._queryApi.query(\n      query,\n      database ??\n        this._options.database ??\n        throwReturn(new Error(argumentErrorMessage)),\n      queryType\n    )\n  }\n\n  /**\n   * Execute a query and return the results as an async generator.\n   *\n   * @param query - The query string.\n   * @param database - The name of the database to query.\n   * @param queryType - The type of query (default: 'sql').\n   * @returns An async generator that yields PointValues object.\n   */\n  queryPoints(\n    query: string,\n    database?: string,\n    queryType: QueryType = 'sql'\n  ): AsyncGenerator<PointValues, void, void> {\n    return this._queryApi.queryPoints(\n      query,\n      database ??\n        this._options.database ??\n        throwReturn(new Error(argumentErrorMessage)),\n      queryType\n    )\n  }\n\n  /**\n   * Closes the client and all its resources (connections, ...)\n   */\n  async close(): Promise<void> {\n    await this._writeApi.close()\n    await this._queryApi.close()\n  }\n}\n"],"mappings":"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","names":["src_exports","__export","AbortError","DEFAULT_ConnectionOptions","DEFAULT_WriteOptions","GetFieldTypeMissmatchError","HttpError","IllegalArgumentError","InfluxDBClient","Log","Point","PointValues","RequestTimedOutError","collectAll","consoleLogger","convertTime","convertTimeToNanos","createTextDecoderCombiner","currentTime","dateToProtocolTimestamp","escape","setLogger","useProcessHrtime","writableDataToLineProtocol","__toCommonJS","IllegalArgumentError","_IllegalArgumentError","message","HttpError","_HttpError","statusCode","statusMessage","body","contentType","e","RequestTimedOutError","_RequestTimedOutError","AbortError","_AbortError","createTextDecoderCombiner","decoder","first","second","retVal","chunk","start","end","DEFAULT_ConnectionOptions","DEFAULT_WriteOptions","consoleLogger","message","error","provider","Log","setLogger","logger","previous","createEscaper","characters","replacements","value","retVal","from","i","found","createQuotedEscaper","escaper","escape","zeroPadding","useHrTime","useProcessHrtime","use","startHrMillis","startHrTime","lastMillis","stepsInMillis","nanos","hrTime","millis","micros","seconds","currentTime","dateToProtocolTimestamp","d","convertTimeToNanos","value","convertTime","precision","throwReturn","err","isDefined","value","isArrayLike","x","createInt32Uint8Array","bytes","collectAll","generator","results","writableDataToLineProtocol","data","arrayData","isArrayLike","p","isDefined","inferType","value","GetFieldTypeMissmatchError","_GetFieldTypeMissmatchError","fieldName","expectedType","actualType","PointValues","_PointValues","name","val","strVal","code","type","fieldEntry","fields","copy","entry","measurement","Point","fieldToLPString","type","value","escape","Point","_Point","arg0","PointValues","name","values","fields","convertTimePrecision","fieldsLine","lpStringValue","tagsLine","x","val","time","convertTime","convertTimeToNanos","line","import_url","http","https","import_buffer","import_zlib","completeCommunicationObserver","callbacks","state","retVal","data","error","headers","statusCode","CLIENT_LIB_VERSION","import_stream","zlibOptions","zlib","emptyBuffer","CancellableImpl","NodeHttpTransport","connectionOptions","_a","_b","_c","_d","_e","_f","_g","_url","proxyUrl","token","transportOptions","nodeSupportedOptions","url","DEFAULT_ConnectionOptions","key","Log","CLIENT_LIB_VERSION","path","body","options","callbacks","cancellable","message","err","responseStarted","buffer","contentType","responseStatusCode","resolve","reject","headers","statusCode","data","responseType","e","terminationError","nestedReject","wrapReject","error","requestMessage","AbortError","response","req","RequestTimedOutError","res","chunk","sendOptions","bodyBuffer","contentEncoding","responseData","isJson","s","HttpError","listeners","completeCommunicationObserver","resume","NodeHttpTransport_default","import_grpc_transport","HTTP_PREFIX","HTTPS_PREFIX","replaceURLProtocolWithPort","url","safe","grpc","createTransport","host","url","safe","replaceURLProtocolWithPort","channelCredentials","implementation","opts","NodeHttpTransport_default","createTransport","node_default","WriteApiImpl","_options","_a","node_default","bucket","writeOptions","org","query","consistency","lines","resolve","reject","promise","res","rej","responseStatusCode","callbacks","_headers","statusCode","error","HttpError","Log","message","writeOptionsOrDefault","DEFAULT_WriteOptions","sendOptions","import_apache_arrow","import_runtime_rpc","typeofJsonValue","value","t","isJsonObject","encTable","decTable","i","base64decode","base64Str","es","bytes","bytePos","groupPos","b","p","base64encode","base64","UnknownFieldHandler","typeName","message","fieldNo","wireType","data","is","writer","no","all","uf","WireType","varint64read","lowBits","highBits","shift","b","middleByte","varint64write","lo","hi","bytes","i","hasNext","byte","splitBits","hasMoreBits","TWO_PWR_32_DBL","int64fromString","dec","minus","base","add1e6digit","begin","end","digit1e6","int64toString","bitsLow","bitsHigh","low","mid","high","digitA","digitB","digitC","decimalFrom1e7","digit1e7","needLeadingZeros","partial","varint32write","value","varint32read","result","readBytes","BI","detectBi","dv","assertBi","bi","RE_DECIMAL_STR","TWO_PWR_32_DBL","HALF_2_PWR_32","SharedPbLong","lo","hi","result","PbULong","_PbULong","value","minus","int64fromString","int64toString","PbLong","_PbLong","pbl","n","defaultsRead","bytes","BinaryReader","binaryReadOptions","options","buf","textDecoder","varint64read","varint32read","tag","fieldNo","wireType","start","WireType","len","t","zze","PbLong","PbULong","lo","hi","s","assert","condition","msg","FLOAT32_MAX","FLOAT32_MIN","UINT32_MAX","INT32_MAX","INT32_MIN","assertInt32","arg","assertUInt32","assertFloat32","defaultsWrite","BinaryWriter","binaryWriteOptions","options","textEncoder","len","bytes","offset","chunk","prev","fieldNo","type","value","assertUInt32","assertInt32","varint32write","assertFloat32","view","long","PbLong","PbULong","varint64write","sign","lo","hi","defaultsWrite","defaultsRead","jsonReadOptions","options","jsonWriteOptions","MESSAGE_TYPE","lowerCamelCase","snakeCase","capNext","sb","i","next","ScalarType","LongType","RepeatType","normalizeFieldInfo","field","_a","_b","_c","_d","lowerCamelCase","isOneofGroup","any","ReflectionTypeCheck","info","_a","req","known","oneofs","field","message","depth","allowExcessProperties","keys","data","n","k","name","group","isOneofGroup","arg","repeated","ScalarType","type","i","longType","argType","LongType","map","reflectionLongConvert","long","type","LongType","ReflectionJsonReader","info","_a","fieldsInput","field","condition","fieldName","jsonValue","what","typeofJsonValue","input","message","options","oneofsHandled","jsonKey","localName","target","isJsonObject","fieldObj","jsonObjKey","jsonObjValue","val","key","ScalarType","LongType","fieldArr","jsonItem","type","json","ignoreUnknownFields","assert","localEnumName","enumNumber","longType","e","float","assertFloat32","int32","assertUInt32","assertInt32","reflectionLongConvert","PbLong","PbULong","base64decode","error","ReflectionJsonWriter","info","_a","message","options","json","source","field","jsonValue","group","opt","assert","value","jsonObj","entryKey","entryValue","val","messageType","enumInfo","jsonArr","i","type","fieldName","optional","emitDefaultValues","enumAsInteger","ed","ScalarType","assertInt32","assertUInt32","assertFloat32","ulong","PbULong","long","PbLong","base64encode","reflectionScalarDefault","type","longType","LongType","ScalarType","reflectionLongConvert","PbULong","PbLong","ReflectionBinaryReader","info","_a","fieldsInput","field","reader","message","options","length","end","fieldNo","wireType","u","d","UnknownFieldHandler","target","repeated","localName","T","ScalarType","L","arr","WireType","e","msg","mapKey","mapVal","key","val","LongType","keyRaw","reflectionScalarDefault","type","longType","reflectionLongConvert","ReflectionBinaryWriter","info","fieldsInput","a","b","message","writer","options","field","value","emitDefault","repeated","localName","group","T","ScalarType","assert","RepeatType","item","key","val","u","UnknownFieldHandler","WireType","keyValue","handler","fieldNo","type","wireType","method","isDefault","i","t","m","d","PbLong","PbULong","reflectionCreate","type","msg","MESSAGE_TYPE","field","name","reflectionScalarDefault","reflectionMergePartial","info","target","source","fieldValue","input","output","field","name","group","i","T","k","reflectionEquals","info","a","b","field","localName","val_a","val_b","t","ScalarType","repeatedPrimitiveEq","primitiveEq","repeatedMsgEq","objectValues","T","type","ba","bb","i","MessageType","name","fields","options","normalizeFieldInfo","ReflectionTypeCheck","ReflectionJsonReader","ReflectionJsonWriter","ReflectionBinaryReader","ReflectionBinaryWriter","value","message","reflectionCreate","reflectionMergePartial","copy","a","b","reflectionEquals","arg","depth","target","source","data","opt","binaryReadOptions","json","jsonReadOptions","jsonWriteOptions","_a","binaryWriteOptions","typeofJsonValue","writer","reader","length","Timestamp$Type","MessageType","msg","ms","PbLong","message","date","options","z","nanosStr","json","target","typeofJsonValue","matches","Timestamp","FlightDescriptor_DescriptorType","CancelStatus","HandshakeRequest$Type","MessageType","HandshakeRequest","HandshakeResponse$Type","HandshakeResponse","BasicAuth$Type","BasicAuth","Empty$Type","Empty","ActionType$Type","ActionType","Criteria$Type","Criteria","Action$Type","Action","CancelFlightInfoRequest$Type","FlightInfo","CancelFlightInfoRequest","RenewFlightEndpointRequest$Type","FlightEndpoint","RenewFlightEndpointRequest","Result$Type","Result","CancelFlightInfoResult$Type","CancelFlightInfoResult","SchemaResult$Type","SchemaResult","FlightDescriptor$Type","FlightDescriptor","FlightInfo$Type","FlightEndpoint$Type","Ticket","Location","Timestamp","Location$Type","Ticket$Type","FlightData$Type","FlightData","PutResult$Type","PutResult","FlightService","import_runtime_rpc","FlightServiceClient","_transport","FlightService","options","method","opt","input","QueryApiImpl","_options","node_default","FlightServiceClient","query","database","queryType","client","ticketData","ticket","Ticket","meta","token","options","flightDataStream","binaryStream","flightData","createInt32Uint8Array","_a","batches","batch","rowIndex","row","columnIndex","name","value","values","PointValues","columnSchema","arrowTypeId","metaType","ArrowType","valueType","_fieldType","_b","argumentErrorMessage","InfluxDBClient","options","writeOptions","IllegalArgumentError","host","QueryApiImpl","WriteApiImpl","data","database","org","_a","writableDataToLineProtocol","throwReturn","query","queryType"]}